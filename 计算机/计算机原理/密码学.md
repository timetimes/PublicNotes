# 密码学

密码学是在有恶意攻击者存在的环境下，保护双方通信安全，用来保护信息安全的核心技术

现代信息安全的基本要求：

* 信息的保密性：防止信息泄漏给未经授权的人（加密解密技术）
* 信息的完整性：防止信息被未经授权的篡改（消息认证码，数字签名）
* 认证性：保证信息来自正确的发送者（消息认证码，数字签名）
* 不可否认性：保证发送者不能否认他们已发送的消息（数字签名）

## 古典密码学

* 加解密过程简单，一般用手工或机械就可以完成
* 数据安全基于算法的保密。这和现代密码有很大的差距，只要知道加密方法，就能轻易的获取明文。现代的密码基于秘钥的加密，算法都是公开的，而且公开的密码算法安全性更高，能被更多人评论和使用，加强漏洞的修补。
* 以字母表为主要加密对象。古典密码大多数是对有意义的文字进行加密，而现代密码是对比特序列进行加密。
* 使用替换和置换技术
* 密码分析方法基于字母与字母组合的频率特性以及明文的可读性

### 置换密码

加密过程中明文的字母保持相同，但是顺序被打乱。只要把位置恢复，就能得到明文。

> 公元前 500 年的古希腊斯巴达邦城，存在一种叫做「棍子加密」的加密方法。找一个腰带，将信息横着写在腰带上，但是这个信息是完全打乱的，需要一个可以解密的棍子，将腰带缠绕在棍子上，就可以恢复出明文。这也是最简单的置换密码的方式。

### 代换密码

明文中的每一个字符被替换成密文中的另一个字符。接收者对密文做反向替换就可以恢复明文。

> 代换密码中最简单的是凯撒密码，它是一种单表代换密码，加密方式就是通过对字母的位移进行加密。比如把字母表右移三位
> 明文：hello world
> 密文：khoor zroug

---

人类自然语言中，字母出现的频率不同来进行破解。比如英文 E 是使用最频繁的，其次是 T/R/N/I/O/A/S 等；有些字母使用的很少，例如 Z/J/K/Q/X 等，这样就可以获得英文字母使用频率分布表

* 单表代换密码 只要用频率分析表就可以破解
* 多名或同音代替密码 是一对多映射，每个明文字母可以加密成多个密文字母。用已知明文攻击比较容易破解。
* 多字母代替密码 每次对一些字母进行代换，隐藏或均匀化字母的自然频度，用于抵抗频率分析。比如 hill 密码，用已知明文攻击比较容易破解。
* 多表代替密码 以一系列（两个以上）代换表依次对明文消息的字母进行代换的加密操作。先把明文分成多份，代换表有很多个，根据序列依次更换代换序列，对每个序列进行加密。

## 现代密码学

现代密码学主要有三个方向：私钥密码（对称密码）、公钥密码（非对称密码）、安全协议

### 私钥密码（Symmetric-key Algorithm）

私钥密码也称对称密码，是对文字的加密转换成对比特序列的加密（相对于古典密码），用同一个密钥进行加密和解密操作，这个密钥发送方和接收方都是要保密的，所以称为私钥密码。它的两个基本操作就是代换和置换就是来源于古典密码学。

对称密码有两个设计原则，一个是扩散（Diffusion）：明文的统计结构被扩散消失到密文的长程统计特性，使得明文和密文之间的统计关系尽量复杂。
另一个是混乱（confusion）：使得密文的统计特性与密钥的取值之间的关系尽量复杂。

AES：目前安全强度较高、应用范围较广的对称加密算法
SM1：国密，采用硬件实现
SM4：国密，可使用软件实现
DES/3DES：已被淘汰或逐步淘汰的常用对称加密算法

### 公钥密码（Asymmetric-key Algorithm）

RSA、SM2（国密）、DH、DSA、ECDSA、ECC

#### RSA算法

原理：给出两个素数，很容易将它们相乘而给出它们的乘积，但想得到这两个素数尤为困难。如果能够解决大整数（比如几百位的整数）分解的快速方法，那么 RSA 算法将轻易被破解。

1）准备两个非常大的素数 $p$ 和 $q$（位数越多越难破解）
2）利用字符串模拟计算大素数 $p$ 和 $q$ 的乘积 $n=pq$
3）同样方法计算 $m=(p-1)(q-1)$，这里的 $m$ 即为 $n$ 的欧拉函数
4）找到一个数 $e(1 \lt e \lt m)$，满足 $gcd(m, e)=1$（即 $e$ 和 $m$ 互素）
5）计算 $e$ 在模 $m$ 域上的逆元 $d$（即满足 $ed \equiv 1 \pmod{m}$）
6）至此，公钥和私钥生成完毕：$(n, e)$ 为公钥，$(n, d)$ 为私钥

将明文 $x$ 转换成数字（字符串取其 ASCII码或者 unicode 值）然后通过幂取模计算出密文 $y$
RSA 加密：$y \equiv x^e \pmod{n}$
RSA 解密：$x \equiv y^d \pmod{n}$

---

破解 RSA 的难点在于对 $n$ 的因数分解，然而大整数的因数分解暂时没有高效的算法

---

```python
# 求两个数字的最大公约数 欧几里得算法
def gcd(a, b):
    if b == 0:
        return a
    else:
        return gcd(b, a % b)
# 计算 ax + by = 1中的x与y的整数解 a与b互质
def ext_gcd(a, b):
    if b == 0:
        x1 = 1
        y1 = 0
        x = x1
        y = y1
        r = a
        return r, x, y
    else:
        r, x1, y1 = ext_gcd(b, a % b)
        x = y1
        y = x1 - a // b * y1
        return r, x, y
# 超大整数超大次幂然后对超大的整数取模 蒙哥马利算法
def exp_mode(base, exponent, n):
    bin_array = bin(exponent)[2:][::-1]
    r = len(bin_array)
    base_array = []
    
    pre_base = base
    base_array.append(pre_base)
    
    for _ in range(r - 1):
        next_base = (pre_base * pre_base) % n 
        base_array.append(next_base)
        pre_base = next_base
        
    a_w_b = __multi(base_array, bin_array, n)
    return a_w_b % n

def __multi(array, bin_array, n):
    result = 1
    for index in range(len(array)):
        a = array[index]
        if not int(bin_array[index]):
            continue
        result *= a
        result = result % n # 加快连乘的速度
    return result

# 生成公钥私钥，p、q为两个超大质数
def gen_key(p, q):
    n = p * q
    fy = (p - 1) * (q - 1)      # 计算与n互质的整数个数 欧拉函数
    e = 65537                    # 选取e   一般选取65537，因为65537展开成二进制的时候，1比较少，0很多，所以加密速度很快
    # generate d
    a = e
    b = fy
    r, x, y = ext_gcd(a, b)
    # 计算出的x不能是负数，如果是负数，说明p、q、e选取失败，不过可以把x加上fy，使x为正数，才能计算。
    if x < 0:
        x = x + fy
    d = x
    # 返回：   公钥     私钥
    return    (n, e), (n, d)
    
# 加密 m是被加密的信息 加密成为c
def encrypt(m, pubkey):
    n = pubkey[0]
    e = pubkey[1]
    
    c = exp_mode(m, e, n)
    return c

# 解密 c是密文，解密为明文m
def decrypt(c, selfkey):
    n = selfkey[0]
    d = selfkey[1]
    
    m = exp_mode(c, d, n)
    return m
    
    
if __name__ == "__main__":
    '''公钥私钥中用到的两个大质数p,q,都是1024位'''
    p = 106697219132480173106064317148705638676529121742557567770857687729397446898790451577487723991083173010242416863238099716044775658681981821407922722052778958942891831033512463262741053961681512908218003840408526915629689432111480588966800949428079015682624591636010678691927285321708935076221951173426894836169
    q = 144819424465842307806353672547344125290716753535239658417883828941232509622838692761917211806963011168822281666033695157426515864265527046213326145174398018859056439431422867957079149967592078894410082695714160599647180947207504108618794637872261572262805565517756922288320779308895819726074229154002310375209
    '''生成公钥私钥'''
    pubkey, selfkey = gen_key(p, q)
    '''需要被加密的信息转化成数字,长度小于秘钥n的长度,如果信息长度大于n的长度,那么分段进行加密,分段解密即可'''
    m = 1356205320457610288745198967657644166379972189839804389074591563666634066646564410685955217825048626066190866536592405966964024022236587593447122392540038493893121248948780525117822889230574978651418075403357439692743398250207060920929117606033490559159560987768768324823011579283223392964454439904542675637683985296529882973798752471233683249209762843835985174607047556306705224118165162905676610067022517682197138138621344578050034245933990790845007906416093198845798901781830868021761765904777531676765131379495584915533823288125255520904108500256867069512326595285549579378834222350197662163243932424184772115345
    c = encrypt(m, pubkey)
    print("被加密后的密文-->%s" % c)
    '''信息解密'''
    d = decrypt(c, selfkey)
    print("被解密后的明文-->%s" % d)
```

### 摘要算法（Digest Algorithm）

摘要算法 是指把任意长度的输入消息数据转化为固定长度的输出数据的一种密码算法，又称为散列函数、哈希函数

摘要算法所产生的固定长度的输出数据称为 摘要值 、 散列值 或 哈希值
摘要算法 通常用来做数据完整性的判定，即对数据进行哈希计算然后比较 摘要值 是否一致

HASH碰撞 这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。

摘要算法主要分为三大类：MD（Message Digest，消息摘要算法）、SHA-1（Secure Hash Algorithm，安全散列算法）和 MAC（Message Authentication Code，消息认证码算法）；另国密标准 SM3 也属于摘要算法。

MD 系列 主要包括 MD2、MD4、MD5
SHA 系列 主要包括 SHA-1、SHA-2 系列（SHA-1 的衍生算法，包含 SHA-224、SHA-256、SHA-384、SHA-512）
MAC 系列 主要包括 HmacMD5、HmacSHA1、HmacSHA256、HmacSHA384 和 HmacSHA512 算法

## 应用

后量子密码算法：当量子计算机理论逐渐成熟，好多像基于离散对数问题、大数分解困难问题的公钥密码学算法都因为量子计算机的出现而被攻破，为了应对这种情况的发生，就出现了后量子密码算法。现在一般是基于格或 hash、超奇异椭圆曲线的同源问题来设计后量子密码算法。

生物密码学：生物密码是 RSA 里的 A，阿德尔曼在 1994 年提出的利用生物的生化特性来做 DNA 计算，可以破解 DES 加密，有人利用生物的加密特性来设计一次性密码本的加密技术。

同态加密：现在主要是 Intel 在研究，现在已经有全同态加密算法了，缺点是效率比较低，但是同态加密在云计算中还是很有用的。

区块链：今年欧密会（密码学三大顶级会议之一）就有 5 篇关于区块链的论文。这表明了许多密码学者开始研究密码学在区块链中的应用，区块链为密码学的发展带来新的活力，密码学也为区块链的发展提供了有力保障。

安全协议：零知识证明协议，安全多方计算协议等。

基于双线性对的密码学：这个是近年研究的一个热点。像属性基加密就是基于双线性对的公钥密码算法，另外配合秘密分享方案也可以用来设计门限签名算法。

### 2FA(Two-factor authentication)

大多数场景下都是使用帐号和密码来进行身份验证，而 2FA 就是除了建立帐号密码之外的第二个关卡。就算账号和密码不小心外泄了，也不至于马上被盗用(但还是要养成定期修改密码的好习惯)。而 2FA 又可以分为硬件版本（指纹、U盾等）和软件版本（验证码、TOTP）两种形式。

#### 验证码

OTP(One Time Password)

虽然短信验证码每次都是随机的，但其实短信在传输的过程中非常不安全。撇开短信不谈，就算验证码是用 App 、电子邮件这些来传输，只要每次你登陆时，服务商试图把验证码「传」给你时，那就有遭窃的可能。

TOTP 的中文全称是基于时间的一次性密码，看名字就知道他也是 OTP 的一种，只不过是基于当前的时间来产生的 OTP

服务器生成带有密钥的 QRCode
通常要实现 TOTP 2FA 的第一步，会让你扫描一个很大的 QRCode ，而这个 QRCode 中就带有服务器想要传给你的秘钥。

有了这串 secret 后 App 要怎么生出下面六码 OTP 呢？答案就是把 secret 跟现在时间去进行杂凑，然后取最后的六码作为 OTP。

总归来说，使用 TOTP 来进行 2FA 的第一步就是通过 QRCode Server 让跟 Client(App) 约定好一个秘密，之后就都用那个秘密跟接下来的时间来进行 Hash 。我们就按这个流程来评估每个步骤的安全性。
一开始要设定 TOTP 2FA 的时候 Github 会生成一个 QRCode 让你扫一下，里面就贴着他要给你的秘钥。如果这个秘钥在传输的过程中一不小心被窃客偷走了，那他日后就可以用这个秘密生出登入所需的 OTP。

因此在设置 TOTP 的时候一定要注意检查网站是否有 HTTPS 类似安全性的问题，或者看看有没有人在你背后扫你的 QRCode 。
App 秘钥帮你存起来后，接下来要考虑的就是 App 安全吗。比如说他不会偷偷把你的秘密去拿卖钱，或者他有没有支持云端备份的功能，一不小心就会外泄。

如果黑客拿不到密钥，那他能不能暴力破解猜到六位的 OTP 呢？简单试算一下，因为 OTP 有六位数字，所以有百万种可能性，而且每 30 秒就换一个全新的毫无规律可言的密钥。如果你想在30秒内猜出来，那一秒就需要进行超过三万次登陆。

但实际上只要连续失败几次，Github 就会暂时把你拦下来(其他网站也是)，而你下次要试的时候验证码又不一样了，所以完全不可能暴力破解破解

因此总的来说，除非你的秘钥一开始就被偷走，否则使用 TOTP 2FA 绝对是足够安全的。

缺点在于，登录多了一步，费时且麻烦，用户会感到不耐烦。而且，它也不意味着账户的绝对安全，入侵者依然可以通过盗取 cookie 或 token，劫持整个对话（session）。

双因素认证还有一个最大的问题，那就是帐户的恢复。
一旦忘记密码或者遗失手机，想要恢复登录，势必就要绕过双因素认证，这就形成了一个安全漏洞。除非准备两套双因素认证，一套用来登录，另一套用来恢复账户。

### 图形码

#### 条形码（Bar Code）

#### 二维码（2-dimensional bar code）

用某种特定的几何图形按一定规律在平面（二维方向上）分布的、黑白相间的、记录数据符号信息的图形；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。

堆叠式/行排式
堆叠式/行排式二维条码又称堆积式二维条码或层排式二维条码），其编码原理是建立在一维条码基础之上，按需要堆积成二行或多行。它在编码设计、校验原理、识读方式等方面继承了一维条码的一些特点，识读设备与条码印刷与一维条码技术兼容。但由于行数的增加，需要对行进行判定，其译码算法与软件也不完全相同于一维条码。有代表性的行排式二维条码有：Code 16K、Code 49、PDF417、MicroPDF417 等。

矩阵式二维码
矩阵式二维条码（又称棋盘式二维条码）它是在一个矩形空间通过黑、白像素在矩阵中的不同分布进行编码。在矩阵相应元素位置上，用点（方点、圆点或其他形状）的出现表示二进制“1”，点的不出现表示二进制的“0”，点的排列组合确定了矩阵式二维条码所代表的意义。矩阵式二维条码是建立在计算机图像处理技术、组合编码原理等基础上的一种新型图形符号自动识读处理码制。具有代表性的矩阵式二维条码有：Code One、MaxiCode、QR Code、 Data Matrix、Han Xin Code、Grid Matrix 等。
常用的码制有：PDF417二维条码、Datamatrix二维条码、QR Code、Code 49、Code 16K、Code one等，除了这些常见的二维条码之外，还有Vericode条码、Maxicode条码、CP条码、Codablock F条码、田字码、 Ultracode条码及Aztec条码。

二维码美化 原理 ai
