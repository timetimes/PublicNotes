# 正则表达式

正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为"元字符"），可以用来描述和匹配字符串的特定模式。
正则表达式可以应用于各种编程语言和文本处理工具中。

字符匹配

- 普通字符：普通字符按照字面意义进行匹配，例如匹配字母 "a" 将匹配到文本中的 "a" 字符。
- 元字符：元字符具有特殊的含义，例如 `\d` 匹配任意数字字符，`\w` 匹配任意字母数字字符，`.` 匹配任意字符（除了换行符）等。

量词

- `*`：匹配前面的模式零次或多次。
- `+`：匹配前面的模式一次或多次。
- `?`：匹配前面的模式零次或一次。
- `{n}`：匹配前面的模式恰好 n 次。
- `{n,}`：匹配前面的模式至少 n 次。
- `{n,m}`：匹配前面的模式至少 n 次且不超过 m 次。

字符类

- `[ ]`：匹配括号内的任意一个字符。例如，`[abc]` 匹配字符 "a"、"b" 或 "c"。
- `[^ ]`：匹配除了括号内的字符以外的任意一个字符。例如，`[^abc]` 匹配除了字符 "a"、"b" 或 "c" 以外的任意字符。

边界匹配

- `^`：匹配字符串的开头。
- `$`：匹配字符串的结尾。
- `\b`：匹配单词边界。
- `\B`：匹配非单词边界。

分组和捕获

- `( )`：用于分组和捕获子表达式。
- `(?: )`：用于分组但不捕获子表达式。

特殊字符

- `\`：转义字符，用于匹配特殊字符本身。
- `.`：匹配任意字符（除了换行符）。
- `|`：用于指定多个模式的选择。

## 正则表达式语法

|模式|描述|
|---|---|
|^|匹配字符串的开头|
|$|匹配字符串的末尾。|
|.|匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。|
|[...]|用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'|
|[^...]|不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。|
|re*|匹配0个或多个的表达式。|
|re+|匹配1个或多个的表达式。|
|re?|匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式|
|re{ n}|精确匹配 n 个前面表达式。例如， o{2} 不能匹配 "Bob" 中的 "o"，但是能匹配 "food" 中的两个 o。|
|re{ n,}|匹配 n 个前面表达式。例如， o{2,} 不能匹配"Bob"中的"o"，但能匹配 "foooood"中的所有 o。"o{1,}" 等价于 "o+"。"o{0,}" 则等价于 "o*"。|
|re{ n, m}|匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式|
|a\| b|匹配a或b|
|(re)|对正则表达式分组并记住匹配的文本|
|(?imx)|正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。|
|(?-imx)|正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。|
|(?: re)|类似 (...), 但是不表示一个组|
|(?imx: re)|在括号中使用i, m, 或 x 可选标志|
|(?-imx: re)|在括号中不使用i, m, 或 x 可选标志|
|(?#...)|注释.|
|(?= re)|前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。|
|(?! re)|前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功|
|(?> re)|匹配的独立模式，省去回溯。|
|\w|匹配字母数字及下划线，等价于'[A-Za-z0-9_]'|
|\W|匹配非字母数字及下划线，等价于'[^A-Za-z0-9_]'|
|\s|匹配任意空白字符，等价于 [ \t\n\r\f]。|
|\S|匹配任意非空字符,等价于 [^ \f\n\r\t\v]|
|\d|匹配任意数字，等价于 [0-9].|
|\D|匹配任意非数字，等价于 [^0-9]|
|\A|匹配字符串开始|
|\Z|匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。|
|\z|匹配字符串结束|
|\G|匹配最后匹配完成的位置。|
|\b|匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。|
|\B|匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。|
|\n, \t, 等.|匹配一个换行符。匹配一个制表符。等|
|\1...\9|匹配第n个分组的内容。|
|\10|匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。|

### 修饰符

标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。
标记不写在正则表达式里，标记位于表达式之外，格式如下：
`/pattern/flags`

|修饰符|含义|描述|
|---|---|---|
|i|ignore - 不区分大小写|将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。|
|g|global - 全局匹配|查找所有的匹配项。|
|m|multi line - 多行匹配|使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。|
|s|特殊字符圆点 . 中包含换行符 \n|默认情况下的圆点 . 是匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \n。

### 运算符优先级

正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

|运算符|描述|
|---|---|
|\|转义符|
|(), (?:), (?=), []|圆括号和方括号|
|*, +, ?, {n}, {n,}, {n,m}|限定符|
|^, $, \任何元字符、任何字符|定位点和序列（即：位置和顺序）|
|\||替换，"或"操作|

- **转义符号：** `\` 是用于转义其他特殊字符的转义符号。它具有最高的优先级。
    
    示例：`\d`、`\.` 等，其中 `\d` 匹配数字，`\.` 匹配点号。
    
- **括号：** 圆括号 `()` 用于创建子表达式，具有高于其他运算符的优先级。
    
    示例：`(abc)+` 匹配 "abc" 一次或多次。
    
- **量词：** 量词指定前面的元素可以重复的次数。
    
    示例：`a*` 匹配零个或多个 "a"。
    
- **字符类：** 字符类使用方括号 `[]` 表示，用于匹配括号内的任意字符。
    
    示例：`[aeiou]` 匹配任何一个元音字母。
    
- **断言：** 断言是用于检查字符串中特定位置的条件的元素。
    
    示例：`^` 表示行的开头，`$` 表示行的结尾。
    
- **连接：** 连接在没有其他运算符的情况下表示字符之间的简单连接。
    
    示例：`abc` 匹配 "abc"。
    
- **管道：** 管道符号 `|` 表示"或"关系，用于在多个模式之间选择一个。
    
    示例：`cat|dog` 匹配 "cat" 或 "dog"。

## 常用正则表达式

**一、校验数字的表达式**

- 数字：`^[0-9]*$`
- n位的数字：`^\d{n}$`
- 至少n位的数字：`^\d{n,}$`
- m-n位的数字：`^\d{m,n}$`
- 零和非零开头的数字：`^(0|[1-9][0-9]*)$`
- 非零开头的最多带两位小数的数字：`^([1-9][0-9]*)+(.[0-9]{1,2})?$`
- 带1-2位小数的正数或负数：`^(\-)?\d+(\.\d{1,2})?$`
- 正数、负数、和小数：`^(\-|\+)?\d+(\.\d+)?$`
- 有两位小数的正实数：`^[0-9]+(.[0-9]{2})?$`
- 有1~3位小数的正实数：`^[0-9]+(.[0-9]{1,3})?$`
- 非零的正整数：`^[1-9]\d*$ `或 `^([1-9][0-9]*){1,3}$ `或 `^\+?[1-9][0-9]*$`
- 非零的负整数：`^\-[1-9][]0-9″*$ `或 `^-[1-9]\d*$`
- 非负整数：`^\d+$` 或 `^[1-9]\d*|0$`
- 非正整数：`^-[1-9]\d*|0$` 或` ^((-\d+)|(0+))$`
- 非负浮点数：`^\d+(\.\d+)?$` 或 `^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$`
- 非正浮点数：`^((-\d+(\.\d+)?)|(0+(\.0+)?))$` 或 `^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$`
- 正浮点数：`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$` 或 `^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$`
- 负浮点数：`^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$` 或` ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`
- 浮点数：`^(-?\d+)(\.\d+)?$` 或 `^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`
^\-?(0{1}|[1-9]+[0-9]*)(\.[0-9]+)?$
  

**二、校验字符的表达式**

- 汉字：^[\u4e00-\u9fa5]{0,}$
- 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
- 长度为3-20的所有字符：^.{3,20}$
- 由26个英文字母组成的字符串：^[A-Za-z]+$
- 由26个大写英文字母组成的字符串：^[A-Z]+$
- 由26个小写英文字母组成的字符串：^[a-z]+$
- 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
- 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
- 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
- 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
- 可以输入含有`^%&’,;=?$\”`等字符：`[^%&',;=?$\x22]+`
- 禁止输入含有`~`的字符：`[^~\x22]+`

**三、特殊需求表达式**

- Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
- 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
- InternetURL：`[a-zA-z]+://[^\s]*` 或` ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$`
- 手机号码：`^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$`
- 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：`^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$`
- 国内电话号码(0511-4405222、021-87888822)：`\d{3}-\d{8}|\d{4}-\d{7}`
- 身份证号(15位、18位数字)：`^\d{15}|\d{18}$`
- 短身份证号码(数字、字母x结尾)：`^([0-9]){7,18}(x|X)?$` 或 `^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$`
- 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：`^[a-zA-Z][a-zA-Z0-9_]{4,15}$`
- 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
- 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`
- 日期格式：^\d{4}-\d{1,2}-\d{1,2}
- 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
- 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$
- 钱的输入格式：
	- 有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：^[1-9][0-9]*$
	- 这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]*)$
	- 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$
	- 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$
	- 必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：^[0-9]+(.[0-9]{2})?$
	- 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$
	- 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$
	- 1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$
	- 备注：这就是最终结果了，别忘了”+”可以用”* ”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里
- xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
- 中文字符的正则表达式：[\u4e00-\u9fa5]
- 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
- 空白行的正则表达式：\n\s*\r (可以用来删除空白行)
- HTML标记的正则表达式：`<(\S*?)[^>]*>.*?</\1>|<.*? /> `(对于复杂的嵌套标记无能为力)
- 首尾空白字符的正则表达式：`^\s*|\s*$`或`(^\s*)|(\s*$)` (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
- 腾讯QQ号：`[1-9][0-9]{4,}` (腾讯QQ号从10000开始)
- 中国邮政编码：`[1-9]\d{5}(?!\d)` (中国邮政编码为6位数字)
- IP地址：`\d+\.\d+\.\d+\.\d+` (提取IP地址时有用)
- IP地址：`((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))`
