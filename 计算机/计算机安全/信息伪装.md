# 信息伪装

隐写术


图隐图
“幻影坦克”：大部分应用显示图片的背景是白色，而程序识别时一般以黑色为背景
修改图片中某些像素点的颜色和透明度，满足和白色叠加时显示的颜色和原来相同；和黑色叠加时尽可能黑
透明度设置为150左右，P=(P-105)* 1.7

准备白底二维码
[二维码](image/二维码.jpg)
[普通图片](image/普通图片.jpg)
注意不能负数，也就是说二维码不要和图片比较暗的地方重合
图片不能太大（500k以内），否则会导致缩略图失真

alpha通道抠图+正片叠底
可以使用ps或python制作，
ps过程：二维码图层复制两层，原图在第三层；第二层调整为(255-255* (1-A))的不透明灰度，混合模式选择线性加深；第一层调整为255* A的不透明灰度，混合模式选择划分；创建二维码图层选区，合并三个图层，选区透明度修改为A，导出png格式含透明度图像
python代码如下：

```python
# 教程、代码依照B站up【偶尔有点小迷糊】
from PIL import Image   # 若提示No module named 'PIL'，则：pip install Pillow

# 打开两张素材图片，其中二维码背景为白色。
# 注意：为了代码简洁，这两张图的分辨率必需要是相同的。
imgPutong = Image.open("普通图片.jpg")          
imgBarcode = Image.open("二维码.jpg")   

# 创建新图片，使用RGBA模式，方便稍后保存为png。新图的分辨率和普通图相同。
imgMix = Image.new("RGBA", (imgPutong.width, imgPutong.height) )

# 填充新图片上的每一个像素
for w in range(imgMix.width):
    for h in range(imgMix.height):
        pxlPutong = imgPutong.getpixel( (w,h) )
        pxlBarcode = imgBarcode.getpixel( (w,h) )

        if pxlBarcode[0] > 200: 
            # 如果二维码上的这个像素为白色，直接复制imgXg对应位置的像素值到imgResult，透明度设为255（不透明）
            imgMix.putpixel( (w, h), (pxlPutong[0], pxlPutong[1], pxlPutong[2], 255) )
        else:
            # 如果二维码上的这个像素为黑色，根据视频中的公式计算出新的rgb值。
            alpha = 150 # 透明度：255 * 60% ≈ 150 （半透明）
            imgMix.putpixel( (w, h), (int( ( pxlPutong[0]- (255-alpha) ) / alpha * 255),
                                      int( ( pxlPutong[1]- (255-alpha) ) / alpha * 255),
                                      int( ( pxlPutong[2]- (255-alpha) ) / alpha * 255),
                                      alpha) )
# 保存图片
imgMix.save("./合成图片.png")
print("生成完毕")
```
