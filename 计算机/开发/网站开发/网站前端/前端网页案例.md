# 案例

## 前端功能

### 裁剪上传图片功能

Cropper.js 是一系列用于图像裁剪的 Web 组件，支持多种浏览器和自定义元素。

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图片裁剪上传优化版</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2196F3;
            --error-color: #f44336;
        }

        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 0 20px;
            background: #f5f5f5;
        }

        .upload-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        #previewBox {
            width: 100%;
            height: 60vh;
            max-height: 600px;
            background: #fff;
            border: 2px dashed #ddd;
            margin: 15px 0;
            position: relative;
            overflow: auto;
        }

        .preview-wrapper {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }

        .preview-card {
            flex: 1;
            padding: 10px;
            border: 1px solid #eee;
            border-radius: 4px;
        }

        .controls {
            position: sticky;
            bottom: 0;
            background: rgba(255,255,255,0.95);
            padding: 15px 0;
            margin-top: 20px;
            border-top: 1px solid #ddd;
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 100;
        }

        input[type="file"] {
            display: none;
        }

        .custom-file-input {
            background: var(--primary-color);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.3s;
        }

        .custom-file-input:hover {
            opacity: 0.9;
        }

        #qualitySlider {
            flex: 1;
            max-width: 200px;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            display: none;
            z-index: 1000;
        }

        .progress-bar {
            height: 4px;
            background: #eee;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress {
            width: 0%;
            height: 100%;
            background: var(--primary-color);
            transition: width 0.3s;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.8);
            display: none;
            z-index: 1001;
        }

        @media (max-width: 600px) {
            #previewBox {
                height: 50vh;
                max-height: 400px;
            }
            
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            
            #qualitySlider {
                width: 100%;
                max-width: none;
            }
        }
    </style>
</head>
<body>
    <div class="upload-container">
        <input type="file" id="fileInput" accept="image/*">
        <label for="fileInput" class="custom-file-input">选择图片</label>

        <div id="previewBox">
            <div id="preview"></div>
        </div>

        <div class="preview-wrapper">
            <div class="preview-card">
                <div>裁剪预览：</div>
                <div id="previewOutput" style="width:150px;height:150px;overflow:hidden"></div>
            </div>
        </div>

        <div class="controls">
            <input type="range" id="qualitySlider" min="0.3" max="1" step="0.1" value="0.8">
            <span id="qualityValue">80%</span>
            <button id="uploadBtn" disabled>上传图片</button>
            <button id="cancelBtn">取消</button>
        </div>

        <div class="progress-bar">
            <div class="progress"></div>
        </div>
    </div>

    <div class="toast" id="toast"></div>
    <div class="loading-overlay" id="loading"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script>
        let cropper = null;
        const toast = document.getElementById('toast');
        const progress = document.querySelector('.progress');
        const loadingOverlay = document.getElementById('loading');

        // 显示提示信息
        function showToast(message, type = 'info') {
            toast.textContent = message;
            toast.style.display = 'block';
            setTimeout(() => toast.style.display = 'none', 3000);
        }

        // 设置加载状态
        function setLoading(show) {
            loadingOverlay.style.display = show ? 'block' : 'none';
        }

        // 初始化裁剪器
        function initCropper(imageSrc) {
            if (cropper) {
                cropper.destroy();
            }

            const preview = document.getElementById('preview');
            preview.innerHTML = `<img src="${imageSrc}" style="max-width: 100%">`;
            const image = preview.querySelector('img');

            cropper = new Cropper(image, {
                aspectRatio: 1,
                viewMode: 1,
                dragMode: 'move',
                autoCropArea: 0.8,
                preview: '#previewOutput',
                checkCrossOrigin: false,
                toggleDragModeOnDblclick: false,
                ready() {
                    autoResizeContainer();
                }
            });
        }

        // 自动调整容器大小
        function autoResizeContainer() {
            const container = document.getElementById('previewBox');
            const viewportHeight = window.innerHeight;
            container.style.maxHeight = `${viewportHeight * 0.7}px`;
        }

        // 文件选择处理
        document.getElementById('fileInput').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;

            // 文件校验
            if (!file.type.startsWith('image/')) {
                showToast('请选择图片文件', 'error');
                return;
            }

            if (file.size > 5 * 1024 * 1024) {
                showToast('文件大小不能超过5MB', 'error');
                return;
            }

            try {
                const reader = new FileReader();
                reader.onload = (e) => {
                    initCropper(e.target.result);
                    document.getElementById('uploadBtn').disabled = false;
                };
                reader.readAsDataURL(file);
            } catch (error) {
                showToast(`文件读取失败: ${error.message}`, 'error');
            }
        });

        // 质量滑块控制
        document.getElementById('qualitySlider').addEventListener('input', function(e) {
            document.getElementById('qualityValue').textContent = 
                `${Math.round(e.target.value * 100)}%`;
        });

        // 上传处理
        document.getElementById('uploadBtn').addEventListener('click', async () => {
            if (!cropper) return;

            const canvas = cropper.getCroppedCanvas({
                width: 800,
                height: 800,
                imageSmoothingQuality: 'high'
            });

            try {
                const quality = document.getElementById('qualitySlider').value;
                setLoading(true);
                showToast('正在处理图片...');
                
                canvas.toBlob(async (blob) => {
                    const formData = new FormData();
                    formData.append('file', blob, `upload_${Date.now()}.jpg`);

                    // 显示上传进度
                    progress.style.width = '0%';
                    const xhr = new XMLHttpRequest();
                    
                    xhr.upload.onprogress = (e) => {
                        if (e.lengthComputable) {
                            const percent = (e.loaded / e.total) * 100;
                            progress.style.width = `${percent}%`;
                        }
                    };

                    xhr.onreadystatechange = () => {
                        if (xhr.readyState === 4) {
                            setLoading(false);
                            if (xhr.status === 200) {
                                showToast('上传成功！');
                                // 这里处理服务器返回结果
                                console.log(JSON.parse(xhr.responseText));
                            } else {
                                showToast(`上传失败: ${xhr.statusText}`, 'error');
                            }
                        }
                    };

                    xhr.open('POST', '/upload', true);
                    xhr.send(formData);

                }, 'image/jpeg', quality);

            } catch (error) {
                setLoading(false);
                showToast(`上传失败: ${error.message}`, 'error');
            }
        });

        // 取消按钮
        document.getElementById('cancelBtn').addEventListener('click', () => {
            if (cropper) {
                cropper.destroy();
                cropper = null;
            }
            document.getElementById('preview').innerHTML = '';
            document.getElementById('uploadBtn').disabled = true;
            document.getElementById('fileInput').value = '';
        });

        // 窗口大小变化时调整容器
        window.addEventListener('resize', autoResizeContainer);
    </script>
</body>
</html>
```

```js
xhr.open('POST', '/upload', true);
xhr.send(formData);
```

这里的 `/upload` 是上传接口的路径。你需要根据你的后端服务实现这个接口。

## 前端效果

[bradtraversy/50projects50days: 50+ mini web projects using HTML, CSS & JS](https://github.com/bradtraversy/50projects50days)

### 粒子效果

[[../../../语言/编程语言/JavaScript/JavaScript#particles.js|particles.js]]

### SVG动画

[[../../../语言/其他语法/HTML,CSS#实现SVG动画|SVG动画]]

### 文字黑洞

摘自https://github.com/heyManNice/htmlCanvas/blob/main/src/textBlackHole.html

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>textBlackHole</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        canvas{
            background: #fff;
            display: block;
            height: 100vh;
            width: 100vw;
        }
    </style>
</head>
<body>
    <canvas></canvas>
</body>
<script>
const CONTENT=`从此之后，四婶也就不再提起祥林嫂。
但有一年的秋季，大约是得到祥林嫂好运的消息之后的又过了两个新年，她竟又站在四叔家的堂前了。桌上放着一个荸荠式的圆篮，檐下一个小铺盖。她仍然头上扎着白头绳，乌裙，蓝夹祆，月白背心，脸色青黄，只是两颊上已经消失了血色，顺着眼，眼角上带些泪痕，眼光也没有先前那样精神了。而且仍然是卫老婆子领着，显出慈悲模样，絮絮的对四婶说：“……这实在是叫作‘天有不测风云’，她的男人是坚实人，谁知道年纪轻轻，就会断送在伤寒上？本来已经好了的，吃了一碗冷饭，复发了。幸亏有儿子；她又能做，打柴摘茶养蚕都来得，本来还可以守着，谁知道那孩子又会给狼衔去的呢？春天快完了，村上倒反来了狼，谁料到？现在她只剩了一个光身了。大伯来收屋，又赶她。她真是走投无路了，只好来求老主人。好在她现在已经再没有什么牵挂，太太家里又凑巧要换人，所以我就领她来。——我想，熟门熟路，比生手实在好得多……”
“我真傻，真的，”祥林嫂抬起她没有神采的眼睛来，接着说。“我单知道下雪的时候野兽在山坳里没有食吃，会到村里来；我不知道春天也会有。我一清早起来就开了门，拿小篮盛了一篮豆，叫我们的阿毛坐在门槛上剥豆去。他是很听话的，我的话句句听；他出去了。我就在屋后劈柴，掏米，米下了锅，要蒸豆。我叫阿毛，没有应，出去口看，只见豆撒得一地，没有我们的阿毛了。他是不到别家去玩的；各处去一问，果然没有。我急了，央人出去寻。直到下半天，寻来寻去寻到山坳里，看见刺柴上桂着一只他的小鞋。大家都说，糟了，怕是遭了狼了。再进去；他果然躺在草窠里，肚里的五脏已经都给吃空了，手上还紧紧的捏着那只小篮呢。……”她接着但是呜咽，说不出成句的话来。四婶起刻还踌躇，待到听完她自己的话，眼圈就有些红了。她想了一想，便教拿圆篮和铺盖到下房去。卫老婆子仿佛卸了一肩重担似的嘘一口气；祥林嫂比初来时候神气舒畅些，不待指引，自己驯熟的安放了铺盖。她从此又在鲁镇做女工了。
大家仍然叫她祥林嫂。`;
const FONT_SIZE = 30;


class Char{
    constructor(originX, originY, char){
        this.originX = originX;
        this.originY = originY;
        this.x = this.#random(0, 1000);
        this.y = this.#random(500, 560);
        this.m = this.#random(1, 7);
        this.char = char;
        this.size = FONT_SIZE;
    }
    #random(min, max){
        return Math.random() * (max - min) + min;
    }
    moved(vx, vy){
        this.x += vx*this.m;
        this.y += vy*this.m; 
    }
    moveTo(x, y,curve="linear"){
        const dx = x - this.x;
        const dy = y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        let force = 1;
        switch(curve){
            case "easeIn":
                force = distance/100;
                break;
            case "RevEaseIn":
                force = -distance/100;
                break;
            case "easeOut":CONTENT
                force = 100/distance;
                if(force > 10) force = 10;
                break;
            case "easeInOut":
                force = distance/100;
                if(force > 1) force = distance/100;
                if(force < -1) force = 100/distance;
                break;
            case "linear":
                force = 1;
                break;
        }
        const angle = Math.atan2(dy, dx);
        const vx = Math.cos(angle) * force;
        const vy = Math.sin(angle) * force;
        this.moved(vx, vy);
    }
}
class Canvas{
    constructor(element){
        if(!element||element.nodeName !== 'CANVAS'){
            throw new Error(`canvas element is required, but received ${element ? element.nodeName : 'null'}`);
        }
        this.canvas = element;
        this.ctx = this.canvas.getContext('2d');
        this.ratio = window.devicePixelRatio || 1;
        this.cWidth = this.canvas.width = window.innerWidth*this.ratio;
        this.cHeight = this.canvas.height = window.innerHeight*this.ratio;
        this.#init();
    }
    #init() {
        this.ctx.font=`${FONT_SIZE}px Arial`;
        this.string = CONTENT;
        this.charWidth = FONT_SIZE+1;
        this.#initTextPos();
        this.mouseX = -1000;
        this.mouseY = -1000;
        this.canvas.addEventListener('mousemove', (e) => {
            this.mouseX = e.clientX*this.ratio;
            this.mouseY = e.clientY*this.ratio;
        });
        this.canvas.addEventListener('mouseleave', (e) => {
            this.mouseX = -1000;
            this.mouseY = -1000; 
        });
        this.#loop();
    }
    #initTextPos(){
        const config = {
            marginLeft: 20,
            marginTop: 20,
            lineHeight: 40,
        }
        const maxCols = Math.floor((this.cWidth - config.marginLeft * 2) / this.charWidth);
        let rowsCount = 0;
        let colsCount = 0;
        let length = 0;
        this.charArr = [];

        for(let i = 0; i < this.string.length; i++){
            let char = this.string[i];
            //换行
            if(char === '\n'){
                rowsCount++;
                colsCount = 2;
                continue;
            }
            if(colsCount >= maxCols){
                rowsCount++;
                colsCount = 0; 
            }
            const x = config.marginLeft + colsCount * this.charWidth;
            const y = config.marginTop + rowsCount * config.lineHeight+FONT_SIZE;
            this.charArr[length]=new Char(x, y, char);
            colsCount++;
            length++;
        }
    }
    draw(){
        //移动文字
        for(const char of this.charArr){
            let dx = this.mouseX - char.x;
            let dy = this.mouseY - char.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if(distance < 300){
                char.moveTo(this.mouseX, this.mouseY,"easeOut");
            }else{
                char.moveTo(char.originX, char.originY,"easeIn");
            }
        }

        //渲染文字
        for(const char of this.charArr){
            this.ctx.font=`${char.size}px Arial`;
            this.ctx.fillText(char.char, char.x, char.y);
        }

        //渲染渐变圆
        const gradient = this.ctx.createRadialGradient(this.mouseX, this.mouseY, 50, this.mouseX, this.mouseY, 250);
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0.1)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(this.mouseX, this.mouseY, 300, 0, 2 * Math.PI);
        this.ctx.fill();
        this.ctx.fillStyle = 'black'; 
    }
    #loop(){
        this.ctx.clearRect(0, 0, this.cWidth, this.cHeight);
        this.draw();
        requestAnimationFrame(this.#loop.bind(this));
    }
}
const canvas = new Canvas(document.querySelector('canvas'));
</script>
</html>
```

###  文字浮动

摘自https://github.com/heyManNice/htmlCanvas/blob/main/src/moveableText.html

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>moveableText</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        canvas{
            background: #fff;
            display: block;
            height: 100vh;
            width: 100vw;
        }
    </style>
</head>
<body>
    <canvas></canvas>
</body>
<script>
const CONTENT=`从此之后，四婶也就不再提起祥林嫂。
但有一年的秋季，大约是得到祥林嫂好运的消息之后的又过了两个新年，她竟又站在四叔家的堂前了。桌上放着一个荸荠式的圆篮，檐下一个小铺盖。她仍然头上扎着白头绳，乌裙，蓝夹祆，月白背心，脸色青黄，只是两颊上已经消失了血色，顺着眼，眼角上带些泪痕，眼光也没有先前那样精神了。而且仍然是卫老婆子领着，显出慈悲模样，絮絮的对四婶说：“……这实在是叫作‘天有不测风云’，她的男人是坚实人，谁知道年纪轻轻，就会断送在伤寒上？本来已经好了的，吃了一碗冷饭，复发了。幸亏有儿子；她又能做，打柴摘茶养蚕都来得，本来还可以守着，谁知道那孩子又会给狼衔去的呢？春天快完了，村上倒反来了狼，谁料到？现在她只剩了一个光身了。大伯来收屋，又赶她。她真是走投无路了，只好来求老主人。好在她现在已经再没有什么牵挂，太太家里又凑巧要换人，所以我就领她来。——我想，熟门熟路，比生手实在好得多……”
“我真傻，真的，”祥林嫂抬起她没有神采的眼睛来，接着说。“我单知道下雪的时候野兽在山坳里没有食吃，会到村里来；我不知道春天也会有。我一清早起来就开了门，拿小篮盛了一篮豆，叫我们的阿毛坐在门槛上剥豆去。他是很听话的，我的话句句听；他出去了。我就在屋后劈柴，掏米，米下了锅，要蒸豆。我叫阿毛，没有应，出去口看，只见豆撒得一地，没有我们的阿毛了。他是不到别家去玩的；各处去一问，果然没有。我急了，央人出去寻。直到下半天，寻来寻去寻到山坳里，看见刺柴上桂着一只他的小鞋。大家都说，糟了，怕是遭了狼了。再进去；他果然躺在草窠里，肚里的五脏已经都给吃空了，手上还紧紧的捏着那只小篮呢。……”她接着但是呜咽，说不出成句的话来。四婶起刻还踌躇，待到听完她自己的话，眼圈就有些红了。她想了一想，便教拿圆篮和铺盖到下房去。卫老婆子仿佛卸了一肩重担似的嘘一口气；祥林嫂比初来时候神气舒畅些，不待指引，自己驯熟的安放了铺盖。她从此又在鲁镇做女工了。
大家仍然叫她祥林嫂。`;
const FONT_SIZE = 30;


class Char{
    constructor(originX, originY, char){
        this.originX = originX;
        this.originY = originY;
        this.x = this.#random(0, 1000);
        this.y = this.#random(500, 560);
        this.char = char;
        this.size = FONT_SIZE;
    }
    #random(min, max){
        return Math.random() * (max - min) + min;
    }
    moved(vx, vy){
        this.x += vx;
        this.y += vy; 
    }
    moveTo(x, y,curve="linear"){
        const dx = x - this.x;
        const dy = y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        let force = 1;
        switch(curve){
            case "easeIn":
                force = distance/100;
                break;
            case "RevEaseIn":
                force = -distance/100;
                break;
            case "easeInOut":
                force = distance/100;
                if(force > 1) force = distance/100;
                if(force < -1) force = 100/distance;
                break;
            case "linear":
                force = 1;
                break;
        }
        const angle = Math.atan2(dy, dx);
        const vx = Math.cos(angle) * force;
        const vy = Math.sin(angle) * force;
        this.moved(vx, vy);
    }
}
class Canvas{
    constructor(element){
        if(!element||element.nodeName !== 'CANVAS'){
            throw new Error(`canvas element is required, but received ${element ? element.nodeName : 'null'}`);
        }
        this.canvas = element;
        this.ctx = this.canvas.getContext('2d');
        this.ratio = window.devicePixelRatio || 1;
        this.cWidth = this.canvas.width = window.innerWidth*this.ratio;
        this.cHeight = this.canvas.height = window.innerHeight*this.ratio;
        this.#init();
    }
    #init() {
        this.ctx.font=`${FONT_SIZE}px Arial`;
        this.string = CONTENT;
        this.charWidth = FONT_SIZE+1;
        this.#initTextPos();
        this.mouseX = -1000;
        this.mouseY = -1000;
        this.canvas.addEventListener('mousemove', (e) => {
            this.mouseX = e.clientX*this.ratio;
            this.mouseY = e.clientY*this.ratio;
        });
        this.canvas.addEventListener('mouseleave', (e) => {
            this.mouseX = -1000;
            this.mouseY = -1000; 
        });
        this.#loop();
    }
    #initTextPos(){
        const config = {
            marginLeft: 20,
            marginTop: 20,
            lineHeight: 40,
        }
        const maxCols = Math.floor((this.cWidth - config.marginLeft * 2) / this.charWidth);
        let rowsCount = 0;
        let colsCount = 0;
        let length = 0;
        this.charArr = [];

        for(let i = 0; i < this.string.length; i++){
            let char = this.string[i];
            //换行
            if(char === '\n'){
                rowsCount++;
                colsCount = 2;
                continue;
            }
            if(colsCount >= maxCols){
                rowsCount++;
                colsCount = 0; 
            }
            const x = config.marginLeft + colsCount * this.charWidth;
            const y = config.marginTop + rowsCount * config.lineHeight+FONT_SIZE;
            this.charArr[length]=new Char(x, y, char);
            colsCount++;
            length++;
        }
    }
    draw(){
        for(const char of this.charArr){
            let dx = this.mouseX - char.x;
            let dy = this.mouseY - char.y;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if(distance < 300){
                char.moveTo(this.mouseX, this.mouseY,"RevEaseIn");
            }else{
                char.moveTo(char.originX, char.originY,"easeIn");
            }
        }

        //渲染
        for(const char of this.charArr){
            this.ctx.font=`${char.size}px Arial`;
            this.ctx.fillText(char.char, char.x, char.y); 
        }
    }
    #loop(){
        this.ctx.clearRect(0, 0, this.cWidth, this.cHeight);
        this.draw();
        requestAnimationFrame(this.#loop.bind(this));
    }
}
const canvas = new Canvas(document.querySelector('canvas'));
</script>
</html>
```