# 计算机辅助证明

数学界的根基，正确性的正面临着威胁。正如同问题 [有没有可能一个数学证明是错的，然而所有人都没注意到呢](https://www.zhihu.com/question/413178224)？里提到的一样，当数学的内容越来越庞大，越来越专业化，人们穷其一生也无法习得所有领域。

计算机辅助证明(Theorem Prover或者Proof Assistant/Checker)

计算机辅助证明可以对人写的证明进行检查，换句话说，我们可以用计算机语言把证明输入计算机，然后计算机验证证明。

辅助证明总是基于一门计算机语言的(如Lean)，我们会了解到这种验证是基于该语言的类型检查器，而类型检查器是程序语言设计的元理论的部分

一道题自己笑不出来证明做，但翻看答案却能看懂。这也恰恰说明前者是包含一些更复杂的东西，后者只是一些按部就班的工作。
所以**想法**则是数学里最玄妙的一部分，它体现了我们对数学的理解，而人的理解不仅仅是读懂记忆了定义，命题，证明，还有更多的诸如建立联系和直觉等等难以言说的东西。想法不仅引导我们构造证明，还会引导数学家提出新的命题，发展新的理解，解决新的问题。这一部分是我们所知甚少的，也是目前科学所无法处理的。
但所幸，为了达到我们的目标，验证证明的正确性，我们只需要处理前三者。或许在集合论的框架下他们可能不尽相同，但在类型论中，他们几乎都是同一种东西：他们都是某个类型的**项**(term)。更准确地说，定义和论断我们都将其看做某个**类型**(type)(如同集合论中集合可以作为元素一样，一个类型也可以作为一个更大类型的项)，而一个证明我们视为它所对应的命题的类型的项。

交互式定理证明的现状是基于类型论的系统（以 Isabelle/HOL、HOL4/HOL Light、Coq、Agda、Lean 为代表）的流行程度远高于基于单纯集合论的系统（以 Mizar 和 Metamath 为代表），并且从现在的状况来看，似乎看不到单纯基于集合论的系统有巨大发展空间。

**计算机对证明的验证是基于类型检查器**

What is maths? I think it can basically be classified into four types of thing. There are definitions, true/false statements, proofs, and ideas.
什么是数学？我认为它基本上可以分为四种类型的事物。有定义、真/假陈述、证明和思想。

Definitions (for example the real numbers, or $\pi$) and true/false statements (for example the statement of Fermat’s Last Theorem or the statement of the Riemann Hypothesis) are part of the science of mathematics: these are black and white things which have a completely rigorous meaning within some foundational system.
定义（例如实数，或 $\pi$ ）和真/假陈述（例如费马大定理的陈述或黎曼猜想的陈述）是数学科学的一部分：这些是黑白分明的事物，在某个基础系统中具有完全严谨的意义。

Proofs are in some sense the currency of mathematics: proofs win prizes. Constructing them is an art, checking them is a science. This explains, very simply, why computer proof verification systems such as Lean, Coq, Isabelle/HOL, Agda… are much better at checking proofs than constructing them.
证明在某种程度上是数学的货币：证明赢得奖项。构建它们是一种艺术，验证它们是一种科学。这很简单地解释了为什么像 Lean、Coq、Isabelle/HOL、Agda 这样的计算机证明验证系统在验证证明方面比构建证明要好得多。

And ideas are the purely artistic part of mathematics. That “lightbulb” moment, the insight which enables you to solve a problem — this is the elusive mathematical idea.
而思想是数学的纯粹艺术部分。那个“灵光一闪”的时刻，那个让你解决问题的洞察力——这就是难以捉摸的数学思想。

集合论中的一个定义，例如实数的定义，或 \pi ，是一个集合。而一个证明是逻辑中的一系列步骤。对我来说，定义和证明在集合论中似乎是两件完全不同的事情。
然而，在类型论中，事情却出人意料地不同。这三个东西——定义、真/假陈述和证明——都是同一种类型的东西！它们都是项。一个群、一个证明、实数——它们都是项。这种定义和证明——集合和逻辑——的统一，似乎使得类型论成为向计算机教授所有本科水平数学的实用基础系统。
在类型理论中，一切皆为项。但有些项是类型。并非每个项都是类型，但每个项都有类型。在 Lean 中，冒号用于表示项的类型

## coq

文件的扩展名通常为`.v`
所有Coq命令已句号`.`结尾。正如分号之于C++。

Coq会无视任何包含于`(* *)`内的字符，这些字符被称作注释（comment）。

```coq
Theorem my_first_proof : (forall A : Prop, A -> A).
Proof.
  intros A.
  intros proof_of_A.
  exact proof_of_A.
Qed.
```

内置命令`Theorem`（定理）完成，随后是定理的名称：`my_first_proof`。如果你想重复使用这条定理，你可以随后用这个名称来指代它。接着是一个冒号`:`，以及对你想证明的定理之叙述，并以句号`.`结尾。
这些证明过程开始于`Proof`命令（没毛病）（和一个句号`.`）。然后是真正的证明过程，可以看到用了三个步骤。最后以`Qed`命令结束这个证明。

- **内嵌语言**（"vernacular" language）管理定义和顶层的用户交互。其每个命令均以一个大写字母开头，如`Theorem`、`Proof`、`Qed`。
- **策略语言**（"tactic" language）用于书写证明。其每个命令均以一个小写字母开头，如`intros`和`exact`。
- Coq语段（term）中的无名语言用于表达你想要证明的命题。其表达式使用了许多操作符和括号，如`(forall A : Prop, A -> A)`。（确切地说，这种语言是内嵌语言的一个子集，但将其视为另一种语言是有帮助的）

`Prop`类型一些命题的例子：

- `(forall x : nat, (x < 5) -> (x < 6))`  
    对于任意自然数 xx ，若我们有任意 x<5x<5 的证明，则 x<6x<6 。  
    换句话说，x<5x<5 可以推导出 x<6x<6
- `(forall x y : nat, x + y = y + x)`  
    对于任意两个自然数 xx 和 yy ，有x+y=y+xx+y=y+x（加法交换律）
- `(forall A : Prop, A -> A)`  
    对于任意命题 AA ，若我们有任意 AA 的证明，则 AA 是可证明的。

## lean

Lean 是微软研究院在 2013 年推出的计算机定理证明器。 Lean4 于 2021 年发布，为 Lean 定理证明器的重新实现，能够生成 C 代码后进行编译，以便开发高效的特定领域自动化。
Lean 是一个交互式定理证明器（Interactive Theorem Prover, ITP），也是一门通用函数式编程语言（从 Lean 3 开始）。
Lean 是用于构建复杂表达式的工具，它基于一种称为 依值类型论（Dependent type theory）的形式语言。

[Programming Language and Theorem Prover — Lean](https://lean-lang.org/)

[Lean Game Server](https://adam.math.hhu.de/)

[Lean Prover 中文文档](https://www.leanprover.cn/)
[Lean community](https://leanprover-community.github.io/)
[Lean perfectoid spaces](https://leanprover-community.github.io/lean-perfectoid-spaces/)

[数学在类型理论中。| Xena --- Mathematics in type theory. | Xena](https://xenaproject.wordpress.com/2020/06/20/mathematics-in-type-theory/)

会为您创建一个 `mathematics_in_lean` 子文件夹，包含一个英文pdf文档和一些示例
这是中文版文档：[leanprover.cn/math-in-lean-zh/index.html](https://www.leanprover.cn/math-in-lean-zh/index.html)

[Lean 4 定理证明 - Lean 4 定理证明](https://www.leanprover.cn/tp-lean-zh/title_page.html)

可以使用在线版lean：[Lean 4 Web](https://live.lean-lang.org/)

### lean工具链安装

为了使用 Lean，需要先安装 [VS Code](https://code.visualstudio.com/) 和 Git，然后安装[elan](https://github.com/leanprover/elan)（Lean 版本管理工具）。
再通过 elan 安装各个 Lean4 版本以及 lake 包管理器，接下来就可以使用 lake 创建自己的 Lean 项目。

在 `VS Code` 中安装 `lean4` 扩展

让 `VS Code` 扩展程序为您安装 `elan` 和 `lean`，或者手动进行。建议使用扩展程序进行安装：
创建一个后缀名为.lean的文本文件（或者任意新建一个文本文件Untitled-1并设置语言为 `Lean4` ），屏幕将出现一个对话框，显示 `Failed to start 'lean' language server` 并有一个按钮 `Install Lean using Elan` 。

手动安装：
打开命令提示符（ `cmd` ）并执行以下命令

```powershell
curl -O --location https://elan.lean-lang.org/elan-init.ps1
powershell -ExecutionPolicy Bypass -f elan-init.ps1
del elan-init.ps1
```

或者您也可以打开一个 `git bash` 窗口，然后运行

```bash
curl https://elan.lean-lang.org/elan-init.sh -sSf | sh
```

或者，在所有支持的平台上：获取您平台的 [latest release](https://github.com/leanprover/elan/releases/latest)，解压它，然后运行包含的安装程序。

当这完成之后，返回到 `Untitled-1` 编辑器，并输入 `#eval 18 + 19`如果你看到 `#eval` 下出现蓝色下划线，并且在右侧 `Lean info view` 面板中显示结果 `37` ，那么你就成功安装了 Lean 4！

```powershell
elan --version   # 输出版本号来测试安装是否成功
elan self update # 更新 elan
elan show        # 显示已安装的 Lean 版本

# 下载最新稳定版本 stable
elan install leanprover/lean4:stable 
# 下载指定 Lean 版本，所有版本可见 https://github.com/leanprover/lean4/releases
elan install leanprover/lean4:v4.10.0

# 切换默认的 Lean 版本
elan default leanprover/lean4:stable
# 切换到 leanprover/lean4:v4.11.0-rc1 
elan default leanprover/lean4:v4.11.0-rc1 

# 设置在当前目录下使用的 Lean 版本
elan override set leanprover/lean4:stable
# info: info: override toolchain for 'xxx' set to 'leanprover/lean4:stable'


lake --version # 使用 elan 默认版本
# 使用指定版本
elan run leanprover/lean4:v4.10.0 lake --version
elan run leanprover/lean4:v4.10.0 lean --version
# 创建指定版本的项目
elan run leanprover/lean4:v4.10.0 lake new package
```

在使用 `elan install leanprover/lean4:stable` 时下载速度过慢，通常是由于网络连接问题（尤其是国内用户访问 GitHub 受限）

方法 1：使用镜像源替换 GitHub 下载地址
在终端中执行以下命令（临时生效，重启后失效）：

linux

```bash
# 设置 GitHub 镜像域名（适用于仓库克隆）
export GITHUB_URL="https://hub.njuu.cf"

# 设置 Lean 二进制文件的镜像源（如清华镜像站）
export LEAN_BINARIES_MIRROR="https://mirrors.tuna.tsinghua.edu.cn/github-release/leanprover/lean4/"
```

windows

```PowerShell
# 设置临时环境变量加速下载
$env:LEAN_BINARIES_MIRROR = "https://mirrors.tuna.tsinghua.edu.cn/github-release/leanprover/lean4/"
```

**方法 2**：手动下载预编译二进制文件
绕过 `elan` 自动下载，直接手动下载并安装。
访问 [Lean4 GitHub Releases](https://github.com/leanprover/lean4/releases)，找到最新稳定版
手动下载二进制包

linux
解压并安装到 elan 目录~/.elan/toolchains/ 重命名目录以匹配版本号mv ~/.elan/toolchains/lean-4.7.0-linux ~/.elan/toolchains/stable

windows
将下载的 `lean-4.7.0-windows.zip` 解压到 `C:\Users\<你的用户名>\.elan\toolchains\` 目录
将解压后的文件夹重命名为 `stable`
配置环境变量：在「用户变量」中新建（变量名：ELAN_HOME 变量值：C:\Users\<用户名>\.elan）    编辑「Path」变量，添加 %ELAN_HOME%\bin
当然也可以直接在「Path」变量添加C:\Users\<用户名>\.elan\bin

创建一个自定义工具链名称： 在 toolchains 目录下，创建一个符号链接或文件夹，命名为自定义工具链名称（例如 my-lean4）。
如果你已经将 Lean 4 解压到 stable，可以直接重命名为 my-lean4，或者创建一个符号链接：
mklink /D C:\Users\dom\.elan\toolchains\my-lean4 C:\Users\dom\.elan\toolchains\stable

设置自定义工具链为默认
elan default my-lean4

如果 `elan` 仍然无法识别你的工具链，可以尝试手动注册：
elan override set my-lean4

方法 3：通过代理加速
如果拥有代理服务器（如 Clash、Shadowsocks），可通过代理加速下载。
使用 Clash、V2Ray 等工具开启全局代理

方法 4：使用 Proxychains（Linux/macOS）
强制 `elan` 通过代理网络连接。


可以直接不使用elan，直接下载lean4并添加环境变量


输入lean --version验证安装

[Lean 4 Web](https://live.lean-lang.org/)

[lake](https://github.com/leanprover/lake) 全称 Lean Make，是 Lean 4 的包管理器，用于创建 Lean 项目，构建 Lean 包和编译 Lean 可执行文件。

可以运行 `lake init` 在当前目录中设置包，或运行 `lake new` 在新目录中创建包。

创建一个名为 `your_project_name` 的空白新项目

```bash
lake new your_project_name
```

这个项目的内容形如

```text
your_project_name
├── YourProjectName
│   └── Basic.lean
├── lakefile.lean
├── lean-toolchain
├── Main.lean
├── YourProjectName.lean
└── ...
```

其中 `lakefile.lean` 是当前项目的配置文件，`lean-toolchain` 是当前项目使用的 Lean 版本。
如果你想在这个现有的工程中引用 Mathlib4，你需要在 `lakefile.lean` 文件尾中加入

```lean
require mathlib from git
  "https://github.com/leanprover-community/mathlib4"
```

```bash
# 构建项目可执行文件
lake build
# 运行
lake exec hello # Hello, world!
# 清理构建文件
lake clean
# 更新依赖
lake update
# 运行 lakefile.lean 的脚本
lake run <script>
```

如果你的项目很简单（例如只有一个证明），可以直接在 `Main.lean` 中编写证明代码。

```lean
-- Main.lean
theorem add_comm (a b : Nat) : a + b = b + a := by
  rw [Nat.add_comm]
```

如果你的项目包含多个证明或模块，建议将代码拆分到多个文件中，并组织成模块化结构。

1. 创建一个新的目录（如 `src/`）来存放代码文件。
2. 在 `src/` 中创建多个 `.lean` 文件，每个文件对应一个模块。
3. 在 `Main.lean` 中导入这些模块。

```lean
-- `src/Basics.lean`定义基础定理
theorem add_zero (a : Nat) : a + 0 = a := by
  rw [Nat.add_zero]

-- `src/Advanced.lean`定义更复杂的定理
theorem mul_comm (a b : Nat) : a * b = b * a := by
  rw [Nat.mul_comm]



-- `Main.lean`
import Basics
import Advanced

-- 使用导入的定理
#eval add_zero 5
#eval mul_comm 3 4
```

- 使用以下命令编译项目：lake build
- - 如果需要运行某些代码（如 `#eval`），可以直接运行：lake run

如果你的项目包含一个主要的 Lean 文件（例如 Main.lean），可以运行它来查看输出。使用以下命令：

这会执行项目中定义的 main 函数（如果存在）。


保存运行缓存会让每次编译节省一两个小时，但它当然也不是必须的：

`lake exe cache get`

点击Restart File 来Built构建
lake build手动构建项目

lake update更新并下载 `mathlib` 及其依赖项

清理项目缓存并重新构建：
某些进程（如 Lean 语言服务器或编辑器）可能正在占用这些文件。
打开任务管理器，结束所有与 Lean 或 `lake` 相关的进程。
lake clean
lake build

基本类型与函数

```lean4
-- 定义自然数和加法
def myAdd (a b : Nat) : Nat := a + b

-- 字符串操作
def greet (name : String) : String := "Hello, " ++ name ++ "!"

-- 调用函数
#eval myAdd 3 5       -- 输出 8
#eval greet "Alice"   -- 输出 "Hello, Alice!"
```


命题与定理证明

```lean4
-- 证明等式对称性
theorem symm {α : Type} {a b : α} (h : a = b) : b = a := by
  rw [h]  -- 使用等式 h 进行重写

-- 证明自然数加法交换律
theorem add_comm (a b : Nat) : a + b = b + a := by
  induction a with
  | zero => simp  -- 基础情况：0 + b = b + 0
  | succ a ih => simp [Nat.add_succ, ih]  -- 归纳步骤，使用归纳假设 ih
```

创建新项目

```shell
lake new my_project  # 创建项目
cd my_project
lake build           # 编译项目
```

```text
my_project/
  ├── lakefile.lean   # 依赖配置
  ├── MyProject/
  │   └── Main.lean   # 主文件
  └── lean-toolchain  # Lean 版本
```

### lean语法

(因为lean没有代码高亮，以下使用haskell实现代码高亮)
代码示例：

```haskell
import Mathlib.Tactic
/- 该语句导入了 mathlib 库中的 Tactic 模块。
Mathlib.Tactic 提供了许多用于证明的战术（tactics），例如 rw（重写）、simp（简化）、ring（环算术）等。 
这些战术是 Lean 中构造和简化证明的重要工具。-/

import Mathlib.Util.Delaborators
/- 该语句导入了 mathlib 中的 Util.Delaborators 模块。
Delaborators 是一种工具，用于将内部的 Lean 表示（elaborated terms）转换为更易读的形式（delaborated terms）。
它通常用于改进错误消息或输出的可读性。-/

set_option warningAsError false
/- 该语句设置了 Lean 的一个选项，表示将警告（warnings）视为错误（errors）的行为被禁用。
默认情况下，如果 warningAsError 设置为 true，任何警告都会导致构建失败。
设置为 false 后，警告不会中断构建过程，但仍会显示在输出中。-/

open Nat
-- 打开 Nat 命名空间，使得可以直接使用自然数相关的定义和操作（如 ℕ、+、* 等），而无需加上前缀 Nat.


#check 2 + 2
-- 使用 #check 命令检查表达式 2 + 2 的类型。Lean 会返回 ℕ（自然数）。

def f (x : ℕ) :=
  x + 3
-- 定义了一个函数 f，它接受一个自然数 x，返回 x + 3。

#check f
-- 检查 f 的类型，Lean 会返回 ℕ → ℕ，表示 f 是一个从自然数到自然数的函数。

#check 2 + 2 = 4
-- 检查命题 2 + 2 = 4 的类型，Lean 会返回 Prop，表示这是一个命题。

def FermatLastTheorem :=
  ∀ x y z n : ℕ, n > 2 ∧ x * y * z ≠ 0 → x ^ n + y ^ n ≠ z ^ n
-- 定义了费马大定理（Fermat's Last Theorem）的形式化表述

#check FermatLastTheorem
-- 检查 FermatLastTheorem 的类型，Lean 会返回 Prop，表示这是一个命题。

theorem easy : 2 + 2 = 4 :=
  rfl
-- 定理 easy 证明了 2 + 2 = 4，使用了 rfl（reflexivity，反射性）战术，因为 2 + 2 和 4 是相等的。

#check easy
-- 检查 easy 的类型，Lean 会返回 2 + 2 = 4，表示这是一个已被证明的命题。

theorem hard : FermatLastTheorem :=
  sorry
-- 定理 hard 声明了费马大定理的证明，但使用了 sorry 作为占位符，表示证明尚未完成。

#check hard

example : ∀ m n : Nat, Even n → Even (m * n) := fun m n ⟨k, (hk : n = k + k)⟩ ↦
  have hmn : m * n = m * k + m * k := by rw [hk, mul_add]
  show ∃ l, m * n = l + l from ⟨_, hmn⟩
-- 这是一个例子，证明了如果 n 是偶数，则 m * n 也是偶数。

example : ∀ m n : Nat, Even n → Even (m * n) :=
fun m n ⟨k, hk⟩ ↦ ⟨m * k, by rw [hk, mul_add]⟩
-- 这是同一个命题的简化证明，使用了 Lean 的简洁语法。

example : ∀ m n : Nat, Even n → Even (m * n) := by
  -- 设 `m` 和 `n` 是自然数，设 `n = 2 * k`
  rintro m n ⟨k, hk⟩
  -- 需证 `m * n` 是某自然数的两倍。那就设它是 `m * k` 的两倍吧
  use m * k
  -- 代入 `n`
  rw [hk]
  -- 剩下的就很显然了
  ring

example : ∀ m n : Nat, Even n → Even (m * n) := by
  rintro m n ⟨k, hk⟩; use m * k; rw [hk]; ring

example : ∀ m n : Nat, Even n → Even (m * n) := by
  intros; simp [*, parity_simps]
```

==证明状态==
当你在 VS Code 中输入上述证明的每一行时，Lean 会在单独的Lean Infoview窗口中显示 **证明状态**，告诉你已经建立了哪些事实，以及要证明你的定理还需要完成什么任务。 当你将光标移到证明的每一步时，你可以看到状态的变化。
Lean 中的典型证明状态可能如下所示：

```haskell
1 goal
x y : ℕ,
h₁ : Prime x,
h₂ : ¬Even x,
h₃ : y > x
⊢ y ≥ 4
```

`⊢` 前面的部分是当前位置处我们所拥有的对象和假设，称为 **语境（context）** 。 在这个例子中，语境包括两个对象，自然数 `x` 和 `y`；包括三个假设，分别具有标识符 `h₁` 、 `h₂` 和 `h₃` （下标用 `\1`、`\2` …… 键入）。 Lean 的语法要求在语境中每个假设都拥有一个名字，叫什么都可以
 最后一行用 `⊢` 标记的代表 **目标（goal）** ，即要证明的事实。

==注释==
多行注释： `/-` 和 `-/` 
单行注释：`--`

==import 导入库==（Mathlib库）用法类似Python
import语句必须放在文件开头
可以自定义库
项目根目录——MIL文件夹——Common.lean文件
则可以通过 import MIL.Common 导入

当 Lean 启动时，它会自动导入库中 `Init` 文件夹的内容，其中包括一些基本定义和结构。

在 Lean 中，乘法左结合，因此 `mul_assoc` 的左侧也可以写成 `(a * b) * c`，但是没必要写括号就最好不写。
在 Lean `(a + b) + c` 中显示 为 `a + b + c`，因为加法符号被定义为左 结合的。
在 Lean 中，`a ≠ b` 是 `a = b → False` 的符号表示。这里的 `False` 是一个通用的假命题，`→` 是 Lean 中表示“蕴含”的符号 。
`a ≤ b` 是 `∃ c, b = a + c` 的符号表示。这个“倒 E”代表“存在”。所以 `a ≤ b` 意味着存在一个数字 `c` 使得 `b = a + c`。这个定义有效是因为在这个游戏中没有负数。

第一，函数`f` 应用到值 `x` 上写为 `f x`(例：`Nat.succ 2`)。第二，当写类型表达式时，箭头是_右结合_的；例如，`Nat.add` 的类型是 `Nat → Nat → Nat`，等价于 `Nat → (Nat → Nat)`。

|**关键字**|**功能**|**示例**|
|---|---|---|
|`import`|导入模块或库，用于引入外部定义和工具。|`import Mathlib.Data.Real.Basic`|
|`example`|定义一个示例，用于展示某个命题的证明。|`example (a b : ℝ) : a + b = b + a := by rw [add_comm]`|
|`theorem`|定义一个定理，表示一个需要证明的命题。|`theorem add_zero (a : ℕ) : a + 0 = a := rfl`|
|`def`|定义一个函数或常量。|`def square (x : ℕ) := x * x`|
|`variable`|声明一个变量，通常用于定义的上下文中。|`variable (a b : ℝ)`|
|`section`|定义一个逻辑分组，用于组织代码和变量作用域。|`section variable (a b : ℝ) ... end`|
|`end`|结束一个 `section` 或模块定义。|`end`|
|`fun`|定义匿名函数（lambda 表达式）。|`fun x ↦ x + 1`|
|`by`|引入战术模式，用于逐步构造证明。|`example : a + b = b + a := by rw [add_comm]`|
|`rw`|重写规则，用于替换表达式。|`rw [add_comm]`|
|`calc`|使用分步计算的方式构造证明。|`calc a + b = b + a := by rw [add_comm]`|
|`sorry`|占位符，表示证明尚未完成。|`theorem hard : a + b = b + a := sorry`|
|`#check`|检查表达式的类型。|`#check a + b`|
|`#eval`|计算并显示表达式的结果。|`#eval 2 + 2`|
|`let`|定义局部变量。|`let x := 2 + 2 in x * x`|
|`match`|模式匹配，用于对数据结构进行解构。|`match x with|
|`inductive`|定义归纳类型。|`inductive Nat|
|`structure`|定义结构体类型。|`structure Point where x : ℕ y : ℕ`|
|`namespace`|定义命名空间，用于组织代码。|`namespace MyNamespace ... end`|
|`open`|打开命名空间，使其中的定义可以直接使用。|`open Nat`|
|`set_option`|设置 Lean 的选项，例如警告或格式化选项。|`set_option pp.unicode true`|
|`axiom`|声明一个公理，表示无需证明的命题。|`axiom add_comm : ∀ a b : ℕ, a + b = b + a`|
|`instance`|定义一个类型类实例。|`instance : Add ℕ where add := Nat.add`|
|`@[attribute]`|为定义或定理添加属性，例如优化或标记用途。|`@[simp] theorem add_zero : a + 0 = a := rfl`|
|`infix`|定义中缀操作符。|`infix:50 "⊕" => MyAdd`|
|`notation`|定义自定义符号或语法。|`notation "ℕ+" => { n : ℕ // n > 0 }`|
|`instance`|定义类型类实例，用于实现某些接口。|`instance : Add ℕ where add := Nat.add`|
|`@[simp]`|标记一个定理为简化规则，用于 `simp` 战术。|`@[simp] theorem add_zero : a + 0 = a := rfl`|
|`@[reducible]`|标记定义为可简化的，用于类型推导。|`@[reducible] def MyNat := ℕ`|
|`@[irreducible]`|标记定义为不可简化的，用于隐藏实现细节。|`@[irreducible] def Secret := ℕ`|

#### 类型

归纳类型
枚举式类型
枚举类型是归纳类型的一种非常特殊的情况，其中构造子根本不需要参数。

Lean 提供 `fun` (或 `λ`)关键字用于从给定表达式创建函数
在 Lean 中，`fun` 关键字用于定义匿名函数（lambda 表达式）。它的作用是创建一个没有显式名称的函数，类似于其他编程语言中的 lambda 表达式或箭头函数。

fun x y z ↦ expression
- `x y z` 是函数的参数。
- `↦`（Unicode 箭头）表示将参数映射到后面的表达式。
- `expression` 是函数的返回值。

定理证明的省略可以通过 sorry或者 by admit 关键字做到。

```lean
theorem commutative_in_natural_number
: \forall x \in \N, x + 1 = 1 + x
:= sorry
```

使用 theorem 关键字的时候，定理名称不可以直接省略。
用 example 关键字书写一个省略了名称的定理。

我们证明定理可以通过 "by" 关键字表示接下来的代码是证明的过程。

```lean
theorem test
: [content]
:= by
  [my proof]
  ....
```

每个表达式都有一个 **类型（Type）**，你可以使用 `#check` 命令来打印它。
`Type` 自己的类型-- Type 1
这个列表是无限的，所以对于每个自然数 `n` 都有一个 `Type n`。`Type` 是 `Type 0` 的缩写
有些操作需要在类型宇宙上具有**多态（Polymorphic）**。例如，`List α` 应该对任何类型的 `α` 都有意义，无论 `α` 存在于哪种类型的宇宙中。所以函数 `List` 有如下的类型：`#check List    -- List.{u} (α : Type u) : Type u`
`u` 是一个遍取类型级别的变量
你可以使用 `universe` 命令来声明宇宙变量，这样就可以定义多态常量：

```haskell
universe u

def F (α : Type u) : Type u := Prod α α

#check F    -- Type u → Type u
```

```lean
/- 定义一些常数 -/

def m : Nat := 1       -- m 是自然数
def n : Nat := 0
def b1 : Bool := true  -- b1 是布尔型
def b2 : Bool := false

/- 检查类型 -/

#check m            -- 输出: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 && b2     -- "&&" is the Boolean and
#check b1 || b2     -- Boolean or
#check true         -- Boolean "true"

/- 求值（Evaluate） -/

#eval 5 * 4         -- 20
#eval m + 2         -- 3
#eval b1 && b2      -- false
```

```lean
#check 2 + 2

def f (x : ℕ) :=
  x + 3

#check f
```

`def` 关键字声明工作环境中的新常量符号。`def` 关键字提供了一个声明新对象的重要方式。
`#check` 命令要求 Lean 给出它的类型，用于向系统询问信息的辅助命令都以井号(#)开头。`#eval`命令让 Lean 计算给出的表达式。
`#print`命令可以打印定理的证明
Lean 还允许你使用 `let` 关键字来引入「局部定义」。表达式 `let a := t1; t2` 定义等价于把 `t2` 中所有的 `a` 替换成 `t1` 的结果。
`variable` 命令指示 Lean 将声明的变量作为绑定变量插入定义中，这些定义通过名称引用它们。
Lean 可以让你把定义放进一个「命名空间」（`namespace`）里，并且命名空间也是层次化的
当你声明你在命名空间 `Foo` 中工作时，你声明的每个标识符都有一个前缀 `Foo.`。在打开的命名空间中，可以通过较短的名称引用标识符，但是关闭命名空间后，必须使用较长的名称。与 `section` 不同，命名空间需要一个名称。只有一个匿名命名空间在根级别上。

```lean
namespace Foo
  def a : Nat := 5
  def f (x : Nat) : Nat := x + 7

  def fa : Nat := f a
  def ffa : Nat := f (f a)

  #check a
  #check f
  #check fa
  #check ffa
  #check Foo.fa
end Foo

-- #check a  -- error
-- #check f  -- error
#check Foo.a
#check Foo.f
#check Foo.fa
#check Foo.ffa

open Foo

#check a
#check f
#check fa
#check Foo.fa
```

像小节一样，命名空间也是可以嵌套的
与小节一样，嵌套的名称空间必须按照打开的顺序关闭。
命名空间和小节有不同的用途：命名空间组织数据，小节声明变量，以便在定义中插入。


```lean
-- proof.lean
theorem my_first_theorem : 1 + 1 = 2 := by
  simp

theorem my_false_theorem : 1 + 1 = 1 := by
  simp

theorem my_syntax_error_themore 1 + 1 = 2 := by
  simp
```

```haskell
def c : ℕ := 5  
--def就是表面这是一个定义的关键字，之后lemma等也同理，而我们定义的是用c作为记号的的东西
-- : 代表定义的东西的类型，:=给出定义的东西具体是什么，给出构造
example : ℝ := π --example 直接给出定义的例子，不使用记号
def foo (bar: A) :B := ...
-- 一种定义函数类型的简单写法 foo : A ->B
-- bar作为变量并且取值类型A，具体的定义内容里面可以使用bar，结果得到一个类型B的东西
variable a:ℝ -- 准确来说是这是声明记号的，类似于令a为一实数，接下来后面可以使用这个记号
```

##### 归纳类型

#### 命题与证明

命题的类型用 `Prop`来表示
对每个元素 `p : Prop`，可以引入另一个类型 `Proof p`，作为 `p` 的证明的类型。「公理」是这个类型中的常值。

`axiom and_comm (p q : Prop) : Proof (Implies (And p q) (And q p))`

在 Lean 中，`theorem` 命令引入了一个新的定理

```lean
variable {p : Prop}
variable {q : Prop}

theorem t1 : p → q → p := fun hp : p => fun hq : q => hp
```

这与常量函数的定义完全相同，唯一的区别是参数是 `Prop` 的元素，而不是 `Type` 的元素。
然而，定义和定理之间有一些实用的区别。正常情况下，永远没有必要展开一个定理的「定义」；通过证明无关性，该定理的任何两个证明在定义上都是相等的。一旦一个定理的证明完成，通常我们只需要知道该证明的存在；证明是什么并不重要。鉴于这一事实，Lean 将证明标记为_不可还原_（irreducible），作为对解析器（更确切地说，是**繁饰器**）的提示，在处理文件时一般不需要展开它。事实上，Lean 通常能够并行地处理和检查证明，因为评估一个证明的正确性不需要知道另一个证明的细节。

和定义一样，`#print` 命令可以展示一个定理的证明。

`show` 命令只是注释类型

`example` 命令声明了一个没有名字也不会永久保存的定理。

Lean 定义了所有标准的逻辑连接词和符号。它们都接收 `Prop` 值。
操作符的优先级如下：`¬ > ∧ > ∨ > → > ↔`。

|Ascii|Unicode|编辑器缩写|定义|
|---|---|---|---|
|True|||True|
|False|||False|
|Not|¬|`\not`, `\neg`|Not|
|/\|∧|`\and`|And|
|\/|∨|`\or`|Or|
|->|→|`\to`, `\r`, `\imp`||
|<->|↔|`\iff`, `\lr`|Iff|

合取引入规则：表达式`And.intro h1 h2` 是 `p ∧ q` 的证明
左、右合取消去规则：表达式`And.left h` 从 `h : p ∧ q` 建立了一个 `p` 的证明。类似地，`And.right h` 是 `q` 的证明。
左、右析取引入规则：表达式 `Or.intro_left q hp` 从证明 `hp : p` 建立了 `p ∨ q` 的证明。类似地，`Or.intro_right p hq` 从证明 `hq : q` 建立了 `p ∨ q` 的证明。
析取消去规则：在表达式 `Or.elim hpq hpr hqr` 中，`Or.elim` 接受三个论证，`hpq : p ∨ q`，`hpr : p → r` 和 `hqr : q → r`，生成 `r` 的证明。

Lean 提供了另一个有用的语法小工具。给定一个归纳类型 `Foo` 的表达式 `e`(可能应用于一些参数)，符号 `e.bar` 是 `Foo.bar e` 的缩写。这为访问函数提供了一种方便的方式，而无需打开名称空间。（我们可以写 `h.left` 来表示 `And.left h`）
Lean 提供了 `Or.inr` 和 `Or.inl` 作为 `Or.intro_right _` 和 `Or.intro_left _` 的缩写。

否定 `¬p` 真正的定义是 `p → False`，所以我们通过从 `p` 导出一个矛盾来获得 `¬p`。
类似地，表达式 `hnp hp` 从 `hp : p` 和 `hnp : ¬p` 产生一个 `False` 的证明。

爆炸原理：连接词`False` 只有一个消去规则 `False.elim`，它表达了一个事实，即矛盾能导出一切。
引入规则：`True` 只有一个引入规则 `True.intro : true`。换句话说，`True` 就是真，并且有一个标准证明 `True.intro`

逻辑等价：表达式 `Iff.intro h1 h2` 从 `h1 : p → q` 和 `h2 : q → p` 生成了 `p ↔ q` 的证明。表达式 `Iff.mp h` 从 `h : p ↔ q` 生成了 `p → q` 的证明。表达式 `Iff.mpr h` 从 `h : p ↔ q` 生成了 `q → p` 的证明。下面是 `p ∧ q ↔ q ∧ p` 的证明



到目前为止，我们看到的引入和消去规则都是构造主义的，也就是说，它们反映了基于命题即类型对应的逻辑连接词的计算理解。普通经典逻辑在此基础上加上了排中律 `p ∨ ¬p`（excluded middle, em）。要使用这个原则，你必须打开经典逻辑命名空间。

排中律的一个结果是双重否定消去规则（double-negation elimination, dne）给出了一种证明任何命题 `p` 的方法：通过假设 `¬p` 来推导出 `false`，相当于证明了 `p`。

逐情况进行证明:

```haskell
open Classical
variable (p : Prop)

example (h : ¬¬p) : p :=
  byCases
    (fun h1 : p => h1)
    (fun h1 : ¬p => absurd h1 h)
```

反证法来证明：

```haskell
open Classical
variable (p : Prop)

example (h : ¬¬p) : p :=
  byContradiction
    (fun h1 : ¬p =>
     show False from h h1)
```


 `have` 结构，它在证明中引入了一个辅助的子目标。
 
Lean 的标准库包含了许多命题逻辑的有效语句的证明，你可以自由地在自己的证明中使用这些证明。下面的列表包括一些常见的逻辑等价式。

交换律：

1. `p ∧ q ↔ q ∧ p`
2. `p ∨ q ↔ q ∨ p`

结合律：

3. `(p ∧ q) ∧ r ↔ p ∧ (q ∧ r)`
4. `(p ∨ q) ∨ r ↔ p ∨ (q ∨ r)`

分配律：

5. `p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r)`
6. `p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r)`

其他性质：

7. `(p → (q → r)) ↔ (p ∧ q → r)`
8. `((p ∨ q) → r) ↔ (p → r) ∧ (q → r)`
9. `¬(p ∨ q) ↔ ¬p ∧ ¬q`
10. `¬p ∨ ¬q → ¬(p ∧ q)`
11. `¬(p ∧ ¬p)`
12. `p ∧ ¬q → ¬(p → q)`
13. `¬p → (p → q)`
14. `(¬p ∨ q) → (p → q)`
15. `p ∨ False ↔ p`
16. `p ∧ False ↔ False`
17. `¬(p ↔ ¬p)`
18. `(p → q) → (¬q → ¬p)`

经典推理：

19. `(p → r ∨ s) → ((p → r) ∨ (p → s))`
20. `¬(p ∧ q) → ¬p ∨ ¬q`
21. `¬(p → q) → p ∧ ¬q`
22. `(p → q) → (¬p ∨ q)`
23. `(¬q → ¬p) → (p → q)`
24. `p ∨ ¬p`
25. `(((p → q) → p) → p)`

`sorry` 标识符神奇地生成任何东西的证明，或者提供任何数据类型的对象。当然，作为一种证明方法，它是不可靠的
有另一个有用的技巧。你可以使用下划线 `_` 作为占位符，而不是 `sorry`。这告诉 Lean 该参数是隐式的，应该自动填充。如果 Lean 尝试这样做并失败了，它将返回一条错误消息「不知道如何合成占位符」

#### 量词与等价

如果 `α` 是任何类型，我们可以将 `α` 上的一元谓词 `p` 作为 `α → Prop` 类型的对象。在这种情况下，给定 `x : α`， `p x` 表示断言 `p` 在 `x` 上成立。类似地，一个对象 `r : α → α → Prop` 表示 `α` 上的二元关系：给定 `x y : α`，`r x y` 表示断言 `x` 与 `y` 相关。

==全称量词==`∀` 可以用 `\forall` 输入，也可以用前两个字母简写 `\fo`。
全称量词 `∀ x : α, p x` 表示，对于每一个 `x : α`，`p x` 成立

与命题连接词一样，在自然演绎系统中，「forall」有引入和消去规则。非正式地，
引入规则是：在 `x : α` 是任意的情况下，给定 `p x` 的证明；就可以得到 `∀ x : α, p x` 的证明。
消去规则是：给定 `∀ x : α, p x` 的证明和任何项 `t : α`，就可以得到 `p t` 的证明。

如果 `p` 是任何表达式，`∀ x : α, p` 不过是 `(x : α) → p` 的替代符号，在 `p` 是命题的情况下，前者比后者更自然。


==存在量词==`∃` 用 `\exists` 或简写 `\ex` 输入
存在量词可以写成 `exists x : α, p x` 或 `∃ x : α, p x`。这两个写法实际上在 Lean 的库中的定义为一个更冗长的表达式，`Exists (fun x : α => p x)`。

存在量词也有一个引入规则和一个消去规则。引入规则很简单：要证明 `∃ x : α, p x`，只需提供一个合适的项 `t` 和对 `p t` 的证明即可。Exists.intro

Lean 提供一个更加方便的消去存在量词的途径，那就是通过 `match` 表达式。
Lean 还提供了一个模式匹配的 `let` 表达式这实际上是上面的 `match` 结构的替代表示法。



等价关系的基本性质：反身性、对称性、传递性。
Eq.refl
Eq.symm
Eq.trans
Eq.subst

库中为 `Eq.refl _` 专门定义了一个符号 `rfl`

Lean 的库包含大量通用的等式，例如：

```lean
variable (a b c : Nat)

example : a + 0 = a := Nat.add_zero a
example : 0 + a = a := Nat.zero_add a
example : a * 1 = a := Nat.mul_one a
example : 1 * a = a := Nat.one_mul a
example : a + b = b + a := Nat.add_comm a b
example : a + b + c = a + (b + c) := Nat.add_assoc a b c
example : a * b = b * a := Nat.mul_comm a b
example : a * b * c = a * (b * c) := Nat.mul_assoc a b c
example : a * (b + c) = a * b + a * c := Nat.mul_add a b c
example : a * (b + c) = a * b + a * c := Nat.left_distrib a b c
example : (a + b) * c = a * c + b * c := Nat.add_mul a b c
example : (a + b) * c = a * c + b * c := Nat.right_distrib a b c
```

在 Lean 中，计算式证明从关键字 `calc` 开始

#### 常用策略

|**战术名称**|**功能**|**示例**|
|---|---|---|
|`rw`|重写规则，用于替换表达式。|`rw [mul_comm]`|
|`simp`|简化表达式，自动应用标记为 `@[simp]` 的定理。|`simp [add_assoc]`|
|`ring`|用于处理环算术的证明。|`ring`|
|`calc`|使用分步计算的方式构造证明。|`calc a + b = b + a := by rw [add_comm]`|
|`exact`|提供一个具体的证明。|`exact h`|
|`intro`|引入假设或变量。|`intro h`|
|`apply`|应用一个定理或假设。|`apply mul_comm`|
|`rfl`|用于证明两个相等的表达式（反射性）。|`rfl`|
|`sorry`|占位符，表示证明尚未完成。|`sorry`|
|`use`|提供存在量词的具体实例。|`use 2`|

重写（rewrite）策略 `rw`，它会使用一个等式，`rw` 在 **目标** 中找到符合等式左侧的部分，然后将这部分替换为等式右侧。例如： 如果 `a`、 `b` 和 `c` 是实数，那么 `mul_assoc a b c` 是等式 `a * b * c = a * (b * c)`, 而 `mul_comm a b` 是等式 `a * b = b * a`。 你想运用这些等式时可以只引用它们的名字。 

```haskell
example (a b c : ℝ) : a * b * c = b * (a * c) := by
  rw [mul_comm a b]
  rw [mul_assoc b a c]
```

你也可以不带参数使用诸如 `mul_assoc` 或者 `mul_comm` 这些等式。这些情况下重写策略会识别它在目标中匹配到的第一个模式。
你还可以只提供一部分参数，例如 `mul_comm a` 识别所有形如 `a * ?` 或者 `? * a` 的模式。
通过在方括号内列出相关等式，可以用一行重写执行多个命令。将光标放在 rewrite 列表中的任意逗号后，仍然可以看到进度。
`rw` 有一种叫做 `nth_rewrite` 的变体，如果目标中存在多处匹配，`nth_rw` 允许你指出想要实施替换的位置。匹配项从 1 开始计数，在下面的例子中 `nth_rewrite 2 [h]` 用 `c` 替换了第二个 `a + b`。

？`rfl` 反射。证明形式为 `X = X` 的目标

`rw [h]`重写、代入。如果 `h` 是等式 `X = Y` 的证明，那么 `rw [h]` 将把目标中的所有 `X` 替换为 `Y`
`rw [← h]` （将 `Y` 替换为 `X` ；通过输入 `\left` 或 `\l` 获取返回箭头。）
`rw [h1, h2]` （一系列重写）
`rw [h] at h1 h2 ⊢` （在两个假设和目标中将 `X` s 改为 `Y` s；用 `\|-` .获取 `⊢` 符号。）`rw [zero_add] at h` 来在 `h` 处进行重写，而不是在目标处进行。
`repeat rw [add_zero]` 将不断将 `? + 0` 改为 `?` ，直到没有更多匹配的 `? + 0` 为止。
`nth_rewrite 2 [h]` 只会更改目标中的第二个 `X` 为 `Y` 。

可以通过将显式变量添加为定理的输入来进行更有针对性的重写。 例如，`rw [add_comm b]` 只会重写形如 `b + ? = ? + b` 的形式，而 `rw [add_comm b c]` 只会重写形如 `b + c = c + b` 的形式。

induction  演绎归纳:如果 `n : ℕ` 是一个对象，并且目标提到 `n` ，那么 `induction n with d hd` 试图通过在 `n` 上的归纳来证明该目标，在后续情况下的归纳变量是 `d` ，归纳假设是 `hd` 。
如果目标是0 + n = n将其转化为两个目标。第一个是 `0 + 0 = 0` ；第二个有一个假设 `hd : 0 + d = d` 和目标 `0 + succ d = succ d` 。
induction b with d hd generalizing c`generalizing c`：在归纳之前，将变量 `c` 一般化（generalize）对变量 `b` 进行归纳。在归纳过程中，确保变量 `c` 是一般化的（即在归纳的每一步中，`c` 都是任意的，而不是固定的）。

？exact精确匹配。如果目标是 `P`，那么如果 `h` 是 `P` 的证明，`exact h` 将证明目标。
如果目标是 `x = 37`，假设是 `h : x = 37` 则 `exact h` 将解决目标。
如果目标是 `x + 0 = x`，那么 `exact add_zero x` 将证明目标。
你可以用 `rw [h]` 然后 `rfl` 来完成证明，但 `exact h` 可以在一行中做到同样的事。

？apply应用。如果 `t : P → Q` 是一个 P⟹Q 的证明，而 `h : P` 是一个 `P` 的证明，那么 `apply t at h` 会将 `h` 转换为证明 `Q`。其原理是，如果您知道 `P` 为真，那么您可以从 `t` 推断出 `Q` 为真。
如果_目标_是 `Q`，那么 `apply t` 会“逆向推理”并将目标转换为 `P`。在这里，如果您想证明 `Q`，那么根据 `t`，只需证明 `P` 即可，因此您可以将目标简化为证明 `P`。
可以repeat apply

intro引入。如果目标是 `P → Q`，那么 `intro h` 将引入 `h : P` 作为假设， 并将目标更改为 `Q`。从数学上讲，要证明 P⟹Q， 我们可以假设 P ，然后证明 Q 。

symm`symm` 策略会将形如 `X = Y` 的目标或假设转换为 `Y = X`。它也适用于 `X ≠ Y` 和 `X ↔ Y`。

cases如果 `n` 是一个数字，那么 `cases n with d` 会将目标分解成两个目标，一个是 `n = 0`，另一个是 `n = succ d`。
?如果 `h` 是一个证明（例如一个假设），那么 `cases h with...` 会将证明分解成用来证明它的各个部分。
`cases` 是一种常用的方法，用于解构存在型假设。它会提取出存在的值和对应的证明。
`obtain` 是一种更灵活的方式，适合处理复杂的存在型假设。
如果你需要手动处理存在型假设，可以使用 `exists.elim`。`exists.elim` 是 Lean 中处理存在型假设的底层工具，但通常 `cases` 或 `obtain` 更简洁。

如果 `n : ℕ` 是一个数字，那么 `cases n with d` 会将目标分解成两个目标，一个是 `n` 被替换为 0，另一个是 `n` 被替换为 `succ d`。这对应于数学上的观点，即每个自然数要么是 `0`，要么是一个后继数。
如果 `h : P ∨ Q` 是一个假设，那么 `cases h with hp hq` 会将一个目标变成两个目标，一个有假设 `hp : P`，另一个有假设 `hq : Q`。
如果 `h : False` 是一个假设，那么 `cases h` 会将一个目标变成没有目标，因为没有方法可以证明 `False`！如果你没有剩余的目标，你就完成了这个关卡。
如果 `h : a ≤ b` 是一个假设，那么 `cases h with c hc` 会创建一个新的数字 `c` 和一个证明 `hc : b = a + c`。这是因为 `a ≤ b` 的_定义_是 `∃ c, b = a + c`。

Lean 的简化器 `simp` 是加强版的 `rw` 。它将用每个用户提供给它的引理 以及所有标记为 `simp` 的引理重写目标。
simp only [add_assoc, add_left_comm, add_comm]

你可以在 Lean 中创建自己的策略。 这里的代码

```lean4
macro "simp_add" : tactic => `(tactic|(
  simp only [add_assoc, add_left_comm, add_comm]))
```

被用来创建一个新的策略 `simp_add`，它会执行 `simp only [add_assoc, add_left_comm, add_comm]`。

让我们定义一个从自然数到自然数的新函数 `pred`，它试图从输入中减去 1。定义如下：

```lean4
pred 0 := 37
pred (succ n) := n
```

?`trivial` 将解决目标 `True`。

contrapose如果你有一个假设`h : a ≠ b`和目标`c ≠ d`
那么 `contrapose! h` 将这个命题替换为所谓的“逆否命题”： 一个假设`h : c = d`和目标`a = b`。
`contrapose!` 是 `contrapose` 的增强版本，它会自动将目标或假设中的否定符号（`¬`）展开。
如果你有多个假设，可以选择性地对某个假设使用 `contrapose`，而不影响其他假设。contrapose h1

decide如果 `decide` 可以找到一种算法来解决目标，它将尝试解决该目标。

```lean4
instance instDecidableEq : DecidableEq ℕ
| 0, 0 => isTrue <| by
  show 0 = 0
  rfl
| succ m, 0 => isFalse <| by
  show succ m ≠ 0
  exact succ_ne_zero m
| 0, succ n => isFalse <| by
  show 0 ≠ succ n
  exact zero_ne_succ n
| succ m, succ n =>
  match instDecidableEq m n with
  | isTrue (h : m = n) => isTrue <| by
    show succ m = succ n
    rw [h]
    rfl
  | isFalse (h : m ≠ n) => isFalse <| by
    show succ m ≠ succ n
    exact succ_ne_succ m n h
```

要_证明_一个“存在性”定理，可以使用 `use` 策略。
`use` 策略可以针对声称存在某些事物的目标进行进展。如果目标声称存在某个具有某些性质的 `x` ，而你又知道 `x = 37` 将会有效，那么 `use 37` 将会取得进展。

`left` 策略将目标 `P ∨ Q` 转换为目标 `P`。当您的假设保证 `P ∨ Q` 为真的原因是由于 `P` 为真时，请使用它。
在内部，这个策略只是应用了一个定理，该定理是 P⟹P∨Q 。
请注意，此策略可能会将一个可解决的目标转换为不可解决的目标。

`right` 策略将 `P ∨ Q` 的目标更改为 `Q` 的目标。 当您的假设`Q` 为真是 `P ∨ Q`为真的原因时使用它。
在策略内部，它只是 `apply` （应用） 了 Q⟹P∨Q 这个定理
请注意，这种策略可以将可解决的目标变成无法解决的目标。

`have` 策略可以用来向关卡添加新的假设，但当然你必须证明它们。
have ha : a = 0然后，你将得到一个新目标 `a = 0` 来证明，在你证明之后，你将在原始目标中拥有一个新的假设 `ha : a = 0` 。
如果你已经有了你想要的 `have` 的证明，你就可以立即创建它。例如，如果你有 `a` 和 `b` 个数字对象，那么`have h2 : succ a = succ b → a = b := succ_inj a b`将直接将新的假设 `h2 : succ a = succ b → a = b` 添加到上下文中，因为你刚刚提供了它的证明（ `succ_inj a b` ）。
如果你手头有证明，你甚至不需要陈述你要证明什么。例如`have h2 := succ_inj a b`将 `h2 : succ a = succ b → a = b` 添加为假设。

?tauto  自反`tauto` 战术可以解决任何仅靠逻辑（即真值表）就能解决的问题。
如果你有一个 `False` 作为假设，那么 `tauto` 将会解决目标。这是因为一个错误的假设意味着任何假设。
如果你的目标是 `True` ，那么 `tauto` 将会解决这个目标。
如果你有两个假设 `h1 : a = 37` 和 `h2 : a ≠ 37` ，那么 `tauto` 将会解决目标，因为它可以从你的假设中证明 `False` ，从而证明目标（因为 `False` 意味着任何东西）。
如果你有一个假设 `h : a ≠ a` ，那么 `tauto` 将会解决目标，因为 `tauto` 足够聪明，知道 `a = a` 是真的，这给了我们寻求的矛盾。
如果您有一个假设 `h : 0 = 1` ，那么 `tauto` 将解决目标，因为 `tauto` 知道 `0 ≠ 1` ，这足以证明 `False` ，这暗示了任何目标。
如果您有一个形式为 `a = 0 → a * b = 0` 的假设，并且您的目标是 `a * b ≠ 0 → a ≠ 0` ，那么 `tauto` 将解决目标，因为目标在逻辑上等同于假设。如果您在这个例子中交换目标和假设， `tauto` 也会解决它。

在证明过程中，如果某个假设已经不需要，可以用 `clear` 删除它
如果需要在证明中合并假设，可以通过 `have`have h := ⟨h1, h2⟩,

在 Lean 中，`let` 和 `have` 都可以用来引入新的假设或定义，但它们的用途和行为略有不同。以下是它们的区别
- **定义一个新变量或表达式**：`let` 用于引入一个新的变量或表达式，并将其绑定到一个值或证明。
- **不会添加到上下文中**：`let` 定义的变量不会作为一个独立的假设添加到上下文中。
- **主要用于局部绑定**：适合在证明中引入中间变量或表达式。
- - **引入一个新的假设或证明**：`have` 用于声明一个新的事实，并提供证明。
- **会添加到上下文中**：`have` 引入的假设会作为一个独立的假设添加到上下文中，可以在后续证明中引用。
- **适合引入中间证明**：适合在证明过程中引入中间结论或辅助假设。

- **全称命题**（`∀ x, P x`）表示对所有 `x` 都成立，通常通过提供具体值（`apply` 或直接调用）、特化（`specialize`）、或引入变量（`intro`）来使用。如果你需要从全称命题中提取某个特定的实例，可以使用 `have` 或 `let`。
- **存在命题**（`∃ x, P x`）表示存在某个 `x` 满足条件，通常通过 `cases` 解构来提取具体值和证明。

##### 转换策略模式

在策略块中，可以使用关键字`conv`进入转换模式(conversion mode)。这种模式允许在假设和目标内部，甚至在函数抽象和依赖箭头内部移动，以应用重写或简化步骤。

#### 常用符号

 当阅读 Lean 文件时，如果你将光标悬停在一个符号上，VS Code 将显示用于输入该符号的语法。
如果你想查看所有可用的缩写，可以按下 Ctrl-Shift-P，然后输入 abbreviations 来访问 `Lean 4: Show all abbreviations` 命令。 如果您的键盘上没有方便使用的反斜杠，可以通过更改 `lean4.input.leader` 设置来改变前导字符。

`ℝ` 字符通过 `\R` 或 `\real` 输入
“或”的符号是`∨`，你可以用`\or`来输入它。
你可以通过输入 `\to` 或者 `\r` 或者 `\->` 来输入 `→`。你也可以就用 ASCII 码 `->`，所以表达式 `Nat -> Nat` 和 `Nat → Nat` 意思是一样的，都表示以一个自然数作为输入并返回一个自然数作为输出的函数类型。Unicode符号 `×` 是笛卡尔积，用 `\times` 输入。小写的希腊字母 `α`，`β`，和 `γ` 等等常用来表示类型变量，可以用 `\a`，`\b`，和 `\g` 来输入。

|**符号**|**含义**|**示例**|
|---|---|---|
|`→`|函数类型或逻辑蕴含|`ℕ → ℕ` 表示从自然数到自然数的函数|
|`∀`|全称量词，表示“对于所有”|`∀ x : ℕ, x + 0 = x`|
|`∃`|存在量词，表示“存在”|`∃ x : ℕ, x > 0`|
|`↦`|匿名函数的映射符号|`fun x ↦ x + 1`|
|`=`|等于|`a = b`|
|`≠`|不等于|`a ≠ b`|
|`≤`|小于等于|`a ≤ b`|
|`≥`|大于等于|`a ≥ b`|
|`∧`|逻辑与|`a > 0 ∧ b > 0`|
|`∨`|逻辑或|`a > 0 ∨ b > 0`|
|`¬`|逻辑非|`¬(a > 0)`|
|`→`|逻辑蕴含|`a > 0 → b > 0`|
|`↔`|逻辑等价|`a > 0 ↔ b > 0`|
|`∑`|求和|`∑ i in s, f i`|
|`∏`|求积|`∏ i in s, f i`|
|`^`|幂运算|`a ^ 2`|
|`∂`|偏导数符号|`∂f / ∂x`|

#### 常用Mathlib库

[mathlib4](https://leanprover-community.github.io/mathlib4_docs/)

|**库名称**|**功能**|**示例**|
|---|---|---|
|`Mathlib.Data.Real.Basic`|提供实数的基本定义和操作。|`import Mathlib.Data.Real.Basic`|
|`Mathlib.Algebra.Group`|提供群论相关的定义和定理。|`import Mathlib.Algebra.Group`|
|`Mathlib.Tactic`|提供常用的证明战术（如 `rw`、`simp` 等）。|`import Mathlib.Tactic`|
|`Mathlib.Data.Nat.Basic`|提供自然数的基本定义和操作。|`import Mathlib.Data.Nat.Basic`|
|`Mathlib.Data.Int.Basic`|提供整数的基本定义和操作。|`import Mathlib.Data.Int.Basic`|
|`Mathlib.Data.List.Basic`|提供列表的基本定义和操作。|`import Mathlib.Data.List.Basic`|
|`Mathlib.Algebra.Ring`|提供环论相关的定义和定理。|`import Mathlib.Algebra.Ring`|
|`Mathlib.Data.Set.Basic`|提供集合的基本定义和操作。|`import Mathlib.Data.Set.Basic`|
|`Mathlib.Logic.Basic`|提供逻辑相关的基本工具（如 `∧`、`∨`、`¬` 等）。|`import Mathlib.Logic.Basic`|
|`Mathlib.Tactic.Ring`|提供 `ring` 战术，用于处理环算术的证明。|`import Mathlib.Tactic.Ring`|

#### 常用定理

|**定理名称**|**功能**|**示例**|
|---|---|---|
|`mul_comm`|乘法交换律：`a * b = b * a`|`rw [mul_comm]`|
|`mul_assoc`|乘法结合律：`a * (b * c) = (a * b) * c`|`rw [mul_assoc]`|
|`add_comm`|加法交换律：`a + b = b + a`|`rw [add_comm]`|
|`add_assoc`|加法结合律：`a + (b + c) = (a + b) + c`|`rw [add_assoc]`|
|`pow_two`|平方定义：`a ^ 2 = a * a`|`rw [pow_two]`|
|`mul_add`|乘法分配律：`a * (b + c) = a * b + a * c`|`rw [mul_add]`|
|`add_mul`|加法分配律：`(a + b) * c = a * c + b * c`|`rw [add_mul]`|
|`sub_sub`|减法结合律：`a - (b - c) = a - b + c`|`rw [sub_sub]`|
|`add_zero`|加法零元：`a + 0 = a`|`rw [add_zero]`|
|`mul_one`|乘法单位元：`a * 1 = a`|`rw [mul_one]`|
|`two_mul`|两倍数：`2 * a = a + a`|`rw [two_mul]`|

`mul_assoc a b c` 是等式 `a * b * c = a * (b * c)`, 而 `mul_comm a b` 是等式 `a * b = b * a`。
`sub_self a` 代表等式 `a - a = 0`

可以在例子或定理之外一次性地声明变量. 当 Lean 在定理的陈述中看到它们时，它会自动将它们包含进来
Lean 提供 `variable` 指令来让这些声明变得紧凑

```haskell
variable (a b c d e f : ℝ)

example (h : a * b = c * d) (h' : e = f) : a * (b * e) = c * (d * f) := by
  rw [h', ← mul_assoc, h, mul_assoc]
```

我们可以把声明的范围放在一个 `section ... end` 块中做成类似其他编程语言中局部变量的效果.

```haskell
section
variable (a b c : ℝ)
end
```

小节也可以嵌套，这允许你逐步增加声明新变量。
为了增加代码可读性，可以命名小节，你必须使用相同的名字关闭它。也可以缩进一个小节中的行

### lean例子

#### 命题

证明以下等式，用真实证明取代「sorry」占位符。

```haskell
variable (p q r : Prop)

--  ∧ 和 ∨ 的交换律
example : p ∧ q ↔ q ∧ p := sorry
example : p ∨ q ↔ q ∨ p := sorry

-- ∧ 和 ∨ 的结合律
example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry
example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry

-- 分配律
example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry
example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry

-- 其他性质
example : (p → (q → r)) ↔ (p ∧ q → r) := sorry
example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry
example : ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry
example : ¬p ∨ ¬q → ¬(p ∧ q) := sorry
example : ¬(p ∧ ¬p) := sorry
example : p ∧ ¬q → ¬(p → q) := sorry
example : ¬p → (p → q) := sorry
example : (¬p ∨ q) → (p → q) := sorry
example : p ∨ False ↔ p := sorry
example : p ∧ False ↔ False := sorry
example : (p → q) → (¬q → ¬p) := sorry
```

答案

```haskell
-- -- 当然使用Mathlib.Tactic的tauto战略可以快速处理这些命题逻辑，不过没有训练意义
-- import Mathlib.Tactic

-- variable (p q r : Prop)

-- example : p ∧ q ↔ q ∧ p := by tauto
-- example : p ∨ q ↔ q ∨ p := by tauto

-- ∧ 和 ∨ 的交换律
example : p ∧ q ↔ q ∧ p := by
  constructor -- constructor 是顶层战术，用于分解双向等价（↔）或构造逻辑与（∧）。
  · intro h -- 在 Lean 的 by 块中，多个战术可以嵌套使用。· 表示当前战术是属于上一层constructor的子步骤。
    exact ⟨h.2, h.1⟩ -- 使用 `h.2` 和 `h.1` 访问 `h` 的字段，点 `.` 用于结构体字段访问。
  · intro h
    exact ⟨h.2, h.1⟩

example : p ∨ q ↔ q ∨ p := by
  constructor
  · intro h
    cases h with -- 使用 `cases` 对 `Or` 类型进行模式匹配，竖线 `|` 表示不同的分支。
    | inl hp => exact Or.inr hp -- `inl` 和 `inr` 是 `Or` 的构造器。
    | inr hq => exact Or.inl hq
  · intro h
    cases h with
    | inl hq => exact Or.inr hq
    | inr hp => exact Or.inl hp

-- ∧ 和 ∨ 的结合律
example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := by
  constructor
  · intro h
    exact ⟨h.1.1, ⟨h.1.2, h.2⟩⟩ -- 使用点 `.` 访问嵌套的字段。
  · intro h
    exact ⟨⟨h.1, h.2.1⟩, h.2.2⟩

example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := by
  constructor
  · intro h
    cases h with -- 使用 `cases` 对嵌套的 `Or` 进行模式匹配。
    | inl h₁ =>
      cases h₁ with
      | inl hp => exact Or.inl hp
      | inr hq => exact Or.inr (Or.inl hq)
    | inr hr => exact Or.inr (Or.inr hr)
  · intro h
    cases h with
    | inl hp => exact Or.inl (Or.inl hp)
    | inr h₁ =>
      cases h₁ with
      | inl hq => exact Or.inl (Or.inr hq)
      | inr hr => exact Or.inr hr

-- 分配律
example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  constructor
  · intro h
    cases h.2 with
    | inl hq => exact Or.inl ⟨h.1, hq⟩
    | inr hr => exact Or.inr ⟨h.1, hr⟩
  · intro h
    cases h with
    | inl h₁ => exact ⟨h₁.1, Or.inl h₁.2⟩
    | inr h₂ => exact ⟨h₂.1, Or.inr h₂.2⟩

example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := by
  constructor
  · intro h
    cases h with
    | inl hp => exact ⟨Or.inl hp, Or.inl hp⟩
    | inr h₁ => exact ⟨Or.inr h₁.1, Or.inr h₁.2⟩
  · intro h
    cases h.1 with
    | inl hp => exact Or.inl hp
    | inr hq =>
      cases h.2 with
      | inl hp => exact Or.inl hp
      | inr hr => exact Or.inr ⟨hq, hr⟩

-- 其他性质
example : (p → (q → r)) ↔ (p ∧ q → r) := by
  constructor
  · intro h ⟨hp, hq⟩
    exact h hp hq
  · intro h hp hq
    exact h ⟨hp, hq⟩

example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := by
  constructor
  · intro h
    exact ⟨fun hp => h (Or.inl hp), fun hq => h (Or.inr hq)⟩
  · intro ⟨hp, hq⟩ h
    cases h with
    | inl hp' => exact hp hp'
    | inr hq' => exact hq hq'

example : ¬(p ∨ q) ↔ ¬p ∧ ¬q := by
  constructor
  · intro h
    exact ⟨fun hp => h (Or.inl hp), fun hq => h (Or.inr hq)⟩
  · intro ⟨hnp, hnq⟩ h
    cases h with
    | inl hp => exact hnp hp
    | inr hq => exact hnq hq

example : ¬p ∨ ¬q → ¬(p ∧ q) := by
  intro h ⟨hp, hq⟩
  cases h with
  | inl hnp => exact hnp hp
  | inr hnq => exact hnq hq

example : ¬(p ∧ ¬p) := by
  intro h
  exact h.2 h.1

example : p ∧ ¬q → ¬(p → q) := by
  intro ⟨hp, hnq⟩ h
  exact hnq (h hp)

example : ¬p → (p → q) := by
  intro hnp hp
  exact False.elim (hnp hp)

example : (¬p ∨ q) → (p → q) := by
  intro h hp
  cases h with
  | inl hnp => exact False.elim (hnp hp)
  | inr hq => exact hq

example : p ∨ False ↔ p := by
  constructor
  · intro h
    cases h with
    | inl hp => exact hp
    | inr hfalse => exact False.elim hfalse
  · intro hp
    exact Or.inl hp

example : p ∧ False ↔ False := by
  constructor
  · intro h
    exact h.2
  · intro h
    exact False.elim h

example : (p → q) → (¬q → ¬p) := by
  intro h hnq hp
  exact hnq (h hp)
```

这些需要一点经典逻辑。

```haskell
open Classical

variable (p q r : Prop)

example : (p → q ∨ r) → ((p → q) ∨ (p → r)) := sorry
example : ¬(p ∧ q) → ¬p ∨ ¬q := sorry
example : ¬(p → q) → p ∧ ¬q := sorry
example : (p → q) → (¬p ∨ q) := sorry
example : (¬q → ¬p) → (p → q) := sorry
example : p ∨ ¬p := sorry
example : (((p → q) → p) → p) := sorry
```

```haskell
open Classical

variable (p q r : Prop)

-- 1. (p → q ∨ r) → ((p → q) ∨ (p → r))
example : (p → q ∨ r) → ((p → q) ∨ (p → r)) := by
  intro h -- 假设 h : p → q ∨ r
  byCases hp : p -- 对 p 进行分类讨论：p 成立或不成立
  · cases h hp with -- 如果 p 成立，进一步分类讨论 h hp 的结果是 q 或 r
    | inl hq => exact Or.inl (fun _ => hq) -- 如果 h hp = q，则构造左分支
    | inr hr => exact Or.inr (fun _ => hr) -- 如果 h hp = r，则构造右分支
  · exact Or.inl (fun hp' => False.elim (hp hp')) -- 如果 p 不成立，则左分支成立

-- 2. ¬(p ∧ q) → ¬p ∨ ¬q
example : ¬(p ∧ q) → ¬p ∨ ¬q := by
  intro h -- 假设 h : ¬(p ∧ q)
  byCases hp : p -- 对 p 进行分类讨论
  · byCases hq : q -- 如果 p 成立，进一步分类讨论 q 是否成立
    · exact False.elim (h ⟨hp, hq⟩) -- 如果 p 和 q 都成立，与 h 矛盾
    · exact Or.inr hq -- 如果 q 不成立，则右分支成立
  · exact Or.inl hp -- 如果 p 不成立，则左分支成立

-- 3. ¬(p → q) → p ∧ ¬q
example : ¬(p → q) → p ∧ ¬q := by
  intro h -- 假设 h : ¬(p → q)
  byCases hp : p -- 对 p 进行分类讨论
  · byCases hq : q -- 如果 p 成立，进一步分类讨论 q 是否成立
    · exact False.elim (h (fun _ => hq)) -- 如果 q 成立，与 h 矛盾
    · exact ⟨hp, hq⟩ -- 如果 q 不成立，则构造 p ∧ ¬q
  · exact False.elim (h (fun hp' => False.elim (hp hp'))) -- 如果 p 不成立，与 h 矛盾

-- 4. (p → q) → (¬p ∨ q)
example : (p → q) → (¬p ∨ q) := by
  intro h -- 假设 h : p → q
  byCases hp : p -- 对 p 进行分类讨论
  · exact Or.inr (h hp) -- 如果 p 成立，则由 h 得到 q，构造右分支
  · exact Or.inl hp -- 如果 p 不成立，则构造左分支

-- 5. (¬q → ¬p) → (p → q)
example : (¬q → ¬p) → (p → q) := by
  intro h -- 假设 h : ¬q → ¬p
  intro hp -- 假设 hp : p
  byCases hq : q -- 对 q 进行分类讨论
  · exact hq -- 如果 q 成立，直接返回 q
  · exact False.elim (h hq hp) -- 如果 q 不成立，与 h 矛盾

-- 6. p ∨ ¬p (经典逻辑中的排中律)
example : p ∨ ¬p := by
  exact em p -- 使用经典逻辑中的排中律 `em`

-- 7. (((p → q) → p) → p)
example : (((p → q) → p) → p) := by
  intro h -- 假设 h : ((p → q) → p) → p
  exact h (fun hpq => h (fun _ => hpq)) -- 构造性地使用 h
```

最后，证明 `¬(p ↔ ¬p)` 且不使用经典逻辑。

```haskell
theorem no_bicond_neg_self (p : Prop) : ¬(p ↔ ¬p) := by
  -- 假设 `p ↔ ¬p` 成立，目标是导出矛盾
  intro h
  -- 分解双向蕴含为两个方向：`p → ¬p` 和 `¬p → p`
  cases h with
  | intro h₁ h₂ =>
    -- 构造性矛盾推导：
    -- 1. 假设 `p` 成立
    have : ¬p := by
      intro hp
      -- 应用 `h₁ : p → ¬p` 到 `hp`，得到 `¬p`
      have hnp := h₁ hp
      -- 此时同时有 `p` 和 `¬p`，矛盾
      contradiction
    -- 2. 应用 `h₂ : ¬p → p` 到 `¬p`，得到 `p`
    have : p := h₂ this
    -- 再次产生矛盾（`p` 和 `¬p` 同时存在）
    contradiction
```

#### 量词

```haskell
def even (n : Nat) : Prop := sorry

def prime (n : Nat) : Prop := sorry

def infinitely_many_primes : Prop := sorry

def Fermat_prime (n : Nat) : Prop := sorry

def infinitely_many_Fermat_primes : Prop := sorry

def goldbach_conjecture : Prop := sorry

def Goldbach's_weak_conjecture : Prop := sorry

def Fermat's_last_theorem : Prop := sorry
```

```haskell
-- 定义偶数
def even (n : Nat) : Prop := ∃ k : Nat, n = 2 * k

-- 定义素数
def prime (n : Nat) : Prop := n > 1 ∧ ∀ m : Nat, m > 0 ∧ m < n → n % m ≠ 0

-- 定义“存在无穷多个素数”
def infinitely_many_primes : Prop := ∀ n : Nat, ∃ p : Nat, p > n ∧ prime p

-- 定义费马素数
def Fermat_prime (n : Nat) : Prop := prime n ∧ ∃ k : Nat, n = 2 ^ (2 ^ k) + 1

-- 定义“存在无穷多个费马素数”
def infinitely_many_Fermat_primes : Prop := ∀ n : Nat, ∃ p : Nat, p > n ∧ Fermat_prime p

-- 定义哥德巴赫猜想
def goldbach_conjecture : Prop := ∀ n : Nat, n > 2 ∧ even n → ∃ p q : Nat, prime p ∧ prime q ∧ n = p + q

-- 定义弱哥德巴赫猜想
def Goldbach's_weak_conjecture : Prop := ∀ n : Nat, n > 5 ∧ n % 2 = 1 → ∃ p q r : Nat, prime p ∧ prime q ∧ prime r ∧ n = p + q + r

-- 定义费马大定理
def Fermat's_last_theorem : Prop := ∀ n : Nat, n > 2 → ∀ a b c : Nat, a > 0 ∧ b > 0 ∧ c > 0 → a ^ n + b ^ n ≠ c ^ n
```

#### 费马大定理n=4

费马大定理在 n=4 时的证明

1. 命题转化
需证明方程 $x^4 + y^4 = z^4$ 无正整数解。  
通过变量替换$c = z^2$，转化为证明更强的命题：方程 $x^4 + y^4 = z^2$无正整数解。
2. 假设存在解并构造勾股数
假设存在正整数解$(x, y, z)$满足：
$$
x^4 + y^4 = z^2
$$
令 \( a = x^2 \)，\( b = y^2 \)，则方程变为：
$$
a^2 + b^2 = z^2
$$
此时 \( (a, b, z) \) 构成一组**素勾股数**（即互质的勾股数）。

3. 勾股数的参数化表示
素勾股数可表示为：
\[
a = m^2 - n^2, \quad b = 2mn, \quad z = m^2 + n^2
\]
其中：
- \( m > n \geq 1 \)
- \( m \) 与 \( n \) 互质
- \( m \) 和 \( n \) 为一奇一偶

由于 \( a = x^2 \) 和 \( b = y^2 \) 是平方数，进一步要求：
- \( m \) 和 \( n \) 本身必须是平方数（否则无法满足平方条件）
- 设 \( m = p^2 \)，\( n = q^2 \)，则：
  \[
  z = m^2 + n^2 = p^4 + q^4
  \]
  由此得到新的方程：
  \[
  p^4 + q^4 = z'^2 \quad (z' = \sqrt{z} < z)
  \]

4. 无穷递降法的应用
从初始解 \( (x, y, z) \) 出发，我们导出了更小的解 \( (p, q, z') \)。  
重复此过程，将生成无限递减的正整数序列：
\[
z > z' > z'' > \cdots
\]
这与**无穷递降原理**矛盾（正整数不能无限递减），故假设错误。

5. 关键点总结
- **核心矛盾**：通过构造无限递减的正整数序列，否定解的存在性
- **勾股数性质**：素勾股数的参数化形式保证了推导的严格性
- **平方数约束**：\( m \) 和 \( n \) 必须为平方数是关键条件

6. 补充说明
费马本人通过这一方法证明了 \( n=4 \) 的情形，其核心思想是：
- 将高次方程转化为勾股数问题
- 利用数论分解性质构造矛盾
- 无穷递降法成为后来研究高次方程的重要工具

需证明的原始命题为：方程无正整数解。

```haskell
import Mathlib.Data.Nat.Basic
import Mathlib.Tactic

-- 定义费马大定理 n = 4 的情况
def Fermat_last_theorem_n4 : Prop :=
  ∀ a b c : Nat, a > 0 ∧ b > 0 ∧ c > 0 → a ^ 4 + b ^ 4 ≠ c ^ 4

-- 辅助引理：如果 a^4 + b^4 = c^4，则可以因式分解为 (c^2 - a^2)(c^2 + a^2) = b^4
lemma factorization (a b c : Nat) (h : a ^ 4 + b ^ 4 = c ^ 4) :
  (c ^ 2 - a ^ 2) * (c ^ 2 + a ^ 2) = b ^ 4 := by
  calc
    (c ^ 2 - a ^ 2) * (c ^ 2 + a ^ 2)
        = c ^ 4 - a ^ 4 := Nat.mul_self_sub_mul_self (c ^ 2) (a ^ 2)
    ... = b ^ 4         := by rw [← h, Nat.add_sub_cancel]

-- 辅助引理：c^2 - a^2 和 c^2 + a^2 是互质的
lemma coprime_factors (a b c : Nat) (h : a ^ 4 + b ^ 4 = c ^ 4) :
  Nat.coprime (c ^ 2 - a ^ 2) (c ^ 2 + a ^ 2) := by
  apply Nat.coprime_of_dvd
  · intro d hd1 hd2
    -- 假设 d 同时整除 c^2 - a^2 和 c^2 + a^2
    have h1 : d ∣ (c ^ 2 + a ^ 2) - (c ^ 2 - a ^ 2) := Nat.dvd_sub hd2 hd1
    rw [Nat.add_sub_cancel] at h1
    -- d ∣ 2a^2，但 d 也必须是奇数，因此 d = 1
    exact Nat.dvd_one_of_dvd_two_mul_self h1
  · intro d hd1 hd2
    -- 同理处理另一方向
    exact Nat.dvd_one_of_dvd_two_mul_self (Nat.dvd_sub hd1 hd2)

-- 证明费马大定理 n = 4 的情况
theorem Fermat_last_theorem_n4_proof : Fermat_last_theorem_n4 := by
  intro a b c h
  -- 假设存在正整数 a, b, c 满足 a^4 + b^4 = c^4
  -- 我们将通过无限递降法（infinite descent）推导出矛盾。
  have h1 : (c ^ 2 - a ^ 2) * (c ^ 2 + a ^ 2) = b ^ 4 := factorization a b c h
  have h2 : Nat.coprime (c ^ 2 - a ^ 2) (c ^ 2 + a ^ 2) := coprime_factors a b c h1
  -- 使用无限递降法构造更小的解
  sorry -- 详细数学推导需要复杂的 Lean 数学库支持
```

#### 自然数加法结合律

**问题陈述**
证明自然数加法满足结合律：  对于任意自然数 `a, b, c`，有 `(a + b) + c = a + (b + c)`。

**定义自然数与加法**
Lean4 标准库已内置自然数（Nat）及其加法，但为了演示，我们手动定义一个简化版本：

```lean4
-- 定义自然数类型
inductive MyNat where
  | zero : MyNat          -- 0
  | succ (n : MyNat) : MyNat  -- 后继函数，n + 1

-- 定义加法函数
def add : MyNat → MyNat → MyNat
  | a, MyNat.zero => a      -- a + 0 = a
  | a, MyNat.succ b => MyNat.succ (add a b)  -- a + (b + 1) = (a + b) + 1

-- 简化符号为 + 
infixl:65 "+" => add
```

**形式化结合律定理**
将结合律声明为定理：

```lean4
theorem add_assoc (a b c : MyNat) : (a + b) + c = a + (b + c) := by
  -- 使用归纳法对 c 进行归纳
  induction c with
  | zero =>
    -- 基本情况：c = 0
    -- 目标：(a + b) + 0 = a + (b + 0)
    simp [add]  -- 简化表达式，根据 add 定义可知两边均为 a + b
  | succ c ih =>
    -- 归纳步骤：假设对 c 成立（归纳假设 ih : (a + b) + c = a + (b + c)）
    -- 目标：证明 (a + b) + c.succ = a + (b + c.succ)
    simp [add, ih]  -- 展开 add 定义，并利用归纳假设重写
    -- 此时目标变为 Nat.succ (a + (b + c)) = Nat.succ (a + (b + c))，显然成立
    <;> rfl
```

**运行验证**
在 Lean4 中执行上述代码，若证明正确，将无错误输出。你还可以通过 `#check` 和 `#print` 查看定理细节：

```lean4
#check add_assoc  -- 输出定理类型：∀ a b c : Nat, (a + b) + c = a + (b + c)
#print add_assoc  -- 显示完整证明过程
```
