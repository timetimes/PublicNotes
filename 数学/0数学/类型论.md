# 类型论

类型论，我们将命题视为由其证明为项“组成的”类型(事实上与集合论不同，我们由元素组成集合，类型论中是先有类型再有其项的，所以其实实际上不能当成一种真正的组成)。那么我们可以朴素地说，一个命题为真当且仅当其对应的类型“非空”，然而我们依旧需要来思考如何将我们传统的命题的一系列性质表达出来。

命题 $P, Q$ 的且命题在两者都为真时为真，所以对于 $p:P,q:Q$ 时，笛卡尔积 $(p,q):P\times Q$ 正好满足我们的条件(设想假设p和q中有一个拿不出来的话(p,q)也是拿不出来的)。类似的或命题也可以视为 $P\sqcup Q$ (无交并)。而对于命题的蕴涵，我们可以表述为当我们有证明 $p:P$ 时，我们可以以此得到证明 $f(p):Q$ ，我们实质上是构造了一个函数类型的项 $f:P\rightarrow Q$ (类似范畴论的 $Hom(P,Q)$ )，这也符合直觉：蕴涵命题实质上给与了我们一个函数，把每个命题P的证明都转化为Q的证明。当然这些操作对于所有类型也都是可以做的。而类型是是多层级的，对于所有命题，他们又是一个更大的类型的项 $P,Q: \mathrm{Prop}$ , 同理一些基本的类型也是更大的类型的项 $\mathbb{R}, \mathrm{Prop}: \mathrm{Type}$ (与集合论只有集合(set)和类(class)两种层级，类型的层级是不断向上的比如说还有 $\mathrm{Type}:\mathrm{Type} \ 1$ 等等，如此可见项与类型之间的界限是模糊的)

通过这种方式，我们又将命题和数学对象都统一成了类型，而证明一个命题就如同构造一个数学对象的实例一样，都是要定义满足这个类型条件的项。这就类似于在程序中声明常量

## 集合

[类型论（type theory）学习笔记 - 知乎](https://zhuanlan.zhihu.com/p/679483353)

对于一个系统，我们进行证明的过程大概类似于：1.先写下几条“语句”，这些语句便是证明的前提，作为正确的存在。2. 然后根据一些“规则”，我们选取适合的前提，然后生成新的内容。不断重复，直到产生一些有意思的东西。 在相继式演算中，将$\Gamma$称为**前件**，或者**语境**，是一个语句的列表。$\Gamma \vdash \Sigma$的意思是，在$\Gamma$的前提下，我们能推导出$\Sigma$语句。
${s\in \Gamma\over\Gamma\vdash s}(var)$

对于类型论系统，一种最普遍的语句是类似于：

$$a:A$$

表明$a$是**类型**$A$中的元素，称这种语句为**判断**(judgment)。

这看起来与集合论中的$a\in A$非常相似，但实际上有很大的不同。

有一种特殊的类型 $\mathcal{U}$，称为**类型宇宙**，或者说是类型的类型。判断$A:\mathcal{U}$的意思便是：$A$是一个类型。

函数类型(function types) $A\to B:\mathcal{U}$

## dd

[HoTT学习笔记1：类型论基础 - 知乎](https://zhuanlan.zhihu.com/p/33483631)

**类型 逻辑 集合 同伦**

$A$ ----------- 命题 -------- 集合 ---------- 空间

$a:A$ -------- 证明 -------- 元素 ---------- 点

$B(x)$ --------- 谓词-------- 集合族 -------- 纤维化

$b(x):B(x)$ --- 条件式证明 -元素族--------- 截面

$\textbf{0,1}$ -----------$\top, \bot$ ----- -- $\varnothing, \{ \varnothing\}$--------- $\varnothing, *$

$A+B$ -------- $A\vee B$ ------ 不交并 -------- 余积

$A\times B$ -------- $A\wedge B$ ------ 对子集合 ------ 积空间

$A\to B$-------- $A\Rightarrow B$ ----- 函数集合 ------ 函数空间

$\Sigma_{(x:A)} B(x)$----- $\exists _{x:A} B(x)$----不交和 ------- 总空间

$\Pi_{(x:A)}B(x)$----- $\forall_{x:A} B(x)$ ----积 -------------截面空间

$\textsf{Id}_A$ ------------ 等于 =--- $\{(x,x)\mid x\in A\}$ --路径空间 $A^I$

作为数学的基础语言之一，同伦类型论是Zermelo-Fraenkel集合论（ZFC）的竞争对手。

- 集合论的基础有两个层次：一阶逻辑的演绎系统，以及用一阶逻辑阐述的特定理论，如ZFC，的公理。类型论本身就是一个演绎系统，不需要在一个超然的结构中阐述。
- 集合论有两个重要概念：集合与命题；类型论只有一个核心概念：类型。命题也是一种类型（见上表）。证明一个命题就是构造一个类型的对象的过程。
- 类型论里的 $a:A$ 是一个**判断**（judgment），我们不能证伪它。集合论里的 $a\in A$ 是一个命题。我们可以证实或证伪它。 一般来说，$A$ 是 $a$ 唯一且确定的类型。而“子集”只是两个对象 $a$ 和 $A$ 之间可能存在的关系。
- 在类型论中，**等于关系**（equality）是一个类型。例如对于 $a,b:A$ ，如果类型 $a=_A b$ 有栖居对象（be inhabited），那么我们称 $a$ 和 $b$ 是**命题等同**（propositionally equal）的。

此外，在类型论中还有一个**判断/定义等同**（judgmental/definitional equality），记为 $a\equiv b :A$。例如我们定义类型为 $\mathbb{N\to N}$ 的函数 $f(x)=x^2$ ，那么 $f(3)$ 和 32 就是定义等同的，在这种情况下我们标记为 $f(x):\equiv x^2$ 。

判断需要基于**假设**（assumptions），假设构成了**语境**（context）。如果类型 $A$ 表示的是一个命题，我们可以省去它的证明的名称，如把 $p:x=_A y$ 写成 $x=_A y$ . 但这里的等于不是判断等同。判断等同不能作为假设，也不能被证明。

在类型论中，**规则**（rules），而不是**公理**（axioms），是最重要的。我们可以把规则视为棋牌规则，把公理视为初始棋子的布局。
