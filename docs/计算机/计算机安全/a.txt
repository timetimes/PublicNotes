互不信任原则，不要信任用户提交的数据，包括第三方系统提供的数据，必要的数据校验必须放在后台校验。
最小权限原则，代码、模块等只拥有可以完成任务的最小权限，不赋予不必要的权限。
禁止明文保存用户敏感数据。
小程序代码（不包括云函数代码）跟传统 Web 应用的前端代码类似，可被外部获取及进行反混淆，重要业务逻辑应放在后台代码或云函数中进行。
后台接口调用以及云函数调用，必须进行有效的身份鉴权



平行越权
平行越权是指相同角色之间的越权。 A1、 A2 都是普通用户， A1 通过请求后台接口 userinfo.php?id=A1 来获取用户 A1 自己的信息，如果 userinfo.php 没有进行权限校验，用户 A1 把请求改为 userinfo.php?id=A2 便可以获取到 A2 用户的信息，造成 A2 用户信息的泄露。

垂直越权
垂直越权是指不同角色之间的越权。 B1 是管理员， B2 是普通用户，管理员 B1 通过请求后台接口 getalluserinfo.php 可以获取所有注册用户的信息，如果 getalluserinfo.php 没有进行权限校验， B2 用户也可以请求 getalluserinfo.php 来获取所有注册用户的信息，出现越权行为。




敏感信息不应以明文、注释、可逆的编码方式（如 base64）、不安全散列函数（如 MD5、 SHA1）等形式出现在小程序文件内。

部分敏感信息如用户的银行卡号、手机号等需要用于展示的，需要进行脱敏处理。常用脱敏规范如下：

敏感信息类型	展示样例
姓名	名字只有两个字，对第一个字打码，如：*三。 多于两个字，只保留第一个和最后一个，其余都打码，如：王*四、欧**五
身份证	只显示第一位和最后一位，如：3****************1
手机号	除去手机国际码后，手机号位数不少于10位时，只显示前三位和最后两位，如：156******77。手机号位数少于10位时，只显示前两位和后两位，如：12*****89。国家码可以完全显示。
银行卡	只显示最后4位，如：************1234








后台（包括云函数与自建后台）
注入漏洞
注入漏洞（SQL、 命令等）通常指用户绕过后台代码限制，直接在数据库、 shell 内执行自定义代码。

常见的注入漏洞有：

SQL 注入
SQL 注入是指 Web 程序代码中对于用户提交的参数未做有效过滤就直接拼接到 SQL 语句中执行，导致参数中的特殊字符打破了 SQL 语句原有逻辑，黑客可以利用该漏洞执行任意 SQL 语句。

开发建议：

使用数据库提供的参数化查询来进行数据库操作，不允许直接通过拼接字符串的方式来合成 SQL 语句。
如果存在部分情况需要通过拼接的方式来合成 SQL ，拼接的变量必须要经过处理：
对于整数，需要判断变量是否为整数类型。
对于字符串，需要对单引号、双引号等做转义处理。
避免 Web 应用显示 SQL 的报错信息。
保证 Web 应用里每一数据层的编码统一。
命令注入
命令注入漏洞是指 Web 应用未对用户可控参数进行有效过滤，攻击者可以构造恶意参数拼接到命令上来执行任意命令。

开发建议：

对用户输入的数据（如 ;、|、&等）进行过滤或转义。
弱口令
弱口令指管理后台的用户名密码设置得较为简单或者使用默认账号。攻击者可以通过登录这些账号修改后台数据或进行下一步的入侵操作。

开发建议：

后台服务禁用默认账号，修改后台弱口令。
敏感服务增加二次验证机制，如短信验证码、邮箱验证码等。
文件上传漏洞
文件上传漏洞是指 Web 应用允许用户上传指定文件，但未对文件类型、格式等做合法性校验，导致可以上传非预期格式的文件。

开发建议：

正确解析上传文件的文件类型，通过白名单的方式限制可上传的文件类型。
文件下载
文件下载漏洞是指 Web 应用允许用户通过指定路径和文件名的方式来下载对应的文件，但未正确限制可下载文件所在的目录范围，导致预期范围外的文件被下载泄露。

开发建议：

正确限制可下载文件所在的目录范围
通过指定文件 id 的方式来查找下载对应的文件
目录遍历
目录遍历是指由后台服务对用户输入验证不足或配置不严谨导致的服务器目录内容泄漏。外部可能通过目录遍历获取系统文件、后台代码等敏感文件。

开发建议：

web 服务配置

服务端禁止展示目录
设置目录访问权限
在每个目录下放置一个空的 index.html 页面
web 应用代码

严格检查文件路径参数，限定文件的范围
条件竞争
条件竞争比较常见的例子是攻击者通过并发 https 请求而达到多次获奖、多次收获、多次获赠等非正常逻辑所能触发的效果。

漏洞代码示例

// 从DB里查询该用户剩余获奖次数，初始值为1
int remain_times = SelectRemainTimes();

if(remain_times > 0){
    EarnRewards();          // 用户获得奖励
    ClearRemainTimes();     // 在DB里把该用户的剩余获奖次数清零
}
开发者的设计本意是只允许用户获得一次奖励，但当出现并发请求时，有可能出现请求 A 和请求 B 都刚好执行完第2行代码的情况，此时两个请求的 remain_times 都为1，也就是可以通过第4行代码的判断，获得两次奖励。
开发建议：
对关键（完整）逻辑加锁操作或把关键逻辑以队列任务的形式去进行处理。